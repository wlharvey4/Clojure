# -*- mode:org; -*-

#+title:Clojure
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-01-09 13:18
#+macro:version Version 0.0.8

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying


* Introduction to Clojure
:PROPERTIES:
:unnumbered: t
:END:

“Clojure is a robust, practical, and fast programming language with a set of
useful features that together form a simple, coherent, and powerful tool.”

- [[https://clojure.org][Clojure Home]]

- [[https://clojure.org/reference/reader][Clojure Reference]]

- [[https://clojure.org/api/api][Clojure API]]

- [[https://clojure.org/guides/getting_started][Clojure Guides]]


Clojure is a dynamic, general-purpose programming language, combining the
approachability and interactive development of a scripting language with an
efficient and robust infrastructure for multithreaded programming.  Clojure is
a compiled language, yet remains completely dynamic --- every feature supported
by Clojure is supported at runtime.  Clojure provides easy access to the Java
frameworks, with optional type hints and type inference, to ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language, and features a rich set of immutable, persistent data structures.
When mutable state is needed, Clojure offers a software transactional memory
system and reactive Agent system that ensure clean, correct, multithreaded
designs.

** Clojure Features

#+texinfo:@heading Dynamic Development

Clojure is a dynamic environment you can interact with.  Almost all of the
language constructs are reified, and thus can be examined and changed.  You can
grow your program, with data loaded, adding features, fixing bugs, testing, in
an unbroken stream.

#+texinfo:@heading LISP

Clojure is a member of the Lisp family of languages.  Many of the features of
Lisp have made it into other languages, but Lisp's approach to code-as-data and
its macro system still set it apart.  Additionally, Clojure’s maps, sets, and
vectors are as first class in Clojure as lists are in Lisp.

#+texinfo:@heading Concurrent Programming

Clojure simplifies multi-threaded programming in several ways.  Because the
core data structures are immutable, they can be shared readily between threads.
Clojure, being a practical language, allows state to change but provides
mechanism to ensure that, when it does so, it remains consistent, while
alleviating developers from having to avoid conflicts manually using locks etc.

#+texinfo:@heading Functional Programming

Clojure provides the tools to avoid mutable state, provides functions as
first-class objects, and emphasizes recursive iteration instead of side-effect
based looping.  Clojure is impure, yet stands behind the philosophy that
programs that are more functional are more robust.

#+texinfo:@heading Runtime Polymorphism

Systems that utilize runtime polymorphism are easier to change and extend.
Clojure offers simple, powerful and flexible mechanisms for runtime
polymorphism.  Clojure’s protocols and datatypes features add mechanisms for
abstraction and data structure definition with no compromises vs the facilities
of the host platform.

#+texinfo:@heading Hosted on the JVM

Clojure is designed to be a hosted language, sharing the JVM type system, GC,
threads etc.  All functions are compiled to JVM bytecode.  Clojure is a great
Java library consumer, offering the dot-target-member notation for calls to
Java.  Clojure supports the dynamic implementation of Java interfaces and
classes.

* Clojure for Brave and True
:PROPERTIES:
:url: https://www.braveclojure.com
:author:   "Daniel Higginbotham"
:author-blog: http://flyingmachinestudios.com
:reviewer-blog: http://tailrecursion.com/~alan
:copyright: 2015
:publisher: "No Starch Press"
:isbn:     1-59327-591-9
:isbn-13:  978-1-59327-591-4
:END:

** Forward
#+cindex:John McCarthy
#+cindex:Lisp
You will eventually learn through reading this book that programming is more
enjoyable after knowing some Clojure.  Clojure is the most elegant programming
language every designed.  Elegance is a quality regularly ascribed to many
dialects in the family of programming languages known collectively as Lisp, or
which Clojure is one.   All Lisps descend from a set of siimple and beautiful
discoveries made by the mathematician John McCarthy in 1958.

** Introduction
:PROPERTIES:
:unnumbered: t
:END:

*** Learning a New Programming Language---A Journey through the Four Labyrinths
To wield Clojure to its fullest, you’ll need to find your way through the four
labyrinths that face every programmer learning a new language:

#+attr_texinfo: :indic b
- The Forest of Tooling ::

     A friendly and efficient programming environment makes it easy to try your
     ideas.  You’ll learn how to set up your environment.

- The Mountain of Language ::

     As you ascend, you’ll gain knowledge of Clojure’s syntax, semantics, and
     data structures.  You’ll learn how to use one of the mightiest programming
     tools, the macro, and learn how to simplify your life with Clojure’s
     concurrency constraints.

- The Cave of Artifacts ::

     In its depths, you’ll learn to build, run, and distribute your own
     programs, and how to use code libraries.  You’ll also learn Clojure’s
     relationship to the Java Virtual Machine (JVM).

- The Cloud Castle of Mindset ::

     In its rarefied air, you’ll come to know they why and how of Lisp and
     functional programming.  You’ll learn about the philosophy of simplicity
     that permeates Clojure, and how to solve problems like a Clojurist.


This book follows three guidelines:

1. It takes the dessert-first approach, giving you the development tools and
   language details you need to start playing with real programs immediately.

2. It assumes zero experience with the JVM, functional programming, or Lisp.
   It covers these topics in detail so you’ll feel confident about what you’re
   doing when you build and run Clojure programs.

3. It eschews /real-world/ examples in favor of more interesting exercises,
   like /assaulting hobbits/ and /tracking glittery vampires/.


By the end, you’ll be able to use Clojure.

*** How this Book is Organized

This book is split into three parts to better guide you through your valient
quest, brave fledgling Clojurist.

#+texinfo:@heading Part I---Environment Setup

Theswe chapters take you on a quick tour of the tools you’ll need to easily
write programs.

#+texinfo:@subheading Chapter 1---Building-Running-and the REPL

There’s something powerful and motivating about getting a real program
running.  Once you can do that, you’re free to experiment, and you can actually
share your work!

In this chapter, you’ll invest a small amount of time to become familiar with a
quick way to build and run Clojure programs.  You’ll learn how to experiment
with code in a running Clojure process using a read-eval-print loop (REPL).
This will tighten your feedback loop and help you learn more efficiently.

#+texinfo:@subheading How to use Emacs---an excellent Clojure Editor

A quick feedback loop is crucial for learning.  In this chapter, I cover Emacs
from the ground up to guarantee you have an efficient Emacs/Clojure workflow.

#+texinfo:@heading Part II---Language Fundamentals

These chapters give you a solid foundation on which to continue learning
Clojure.  You’ll start by learning Clojure’s basics (syntax, semantics, and
data structures) so you can /do things/.  Then you’ll take a step back to
examine Clojure’s most used functions in detail and learn how to solve problems
with them using the /functional programming/ mindset.

#+texinfo:@subheading Chapter 3---Do Things---a Clojure Crash Course

Clojure’s most salient characteristic is that it is a Lisp.  You’ll explore
this Lisp core, which is composed of two parts: functions and data.

#+texinfo:@subheading Chapter 4---Core Functions in Depth

In this chapter you’ll learn about a couple of Clojure’s underlying concepts.
This will give you the grounding you need to read the documentation for
functions you haven’t used before and to understand what’s happening when you
try them.

You’ll also see usage examples of the functions you’ll be reading for the
most.  This will give you a solid foundation for writing your own code and for
reading and learning from other people’s projects.

#+texinfo:@subheading Chapter 5---Functional Programming

In this chapter, you’ll take your concrete experience with functions and data
structures and integrate it with a new mindset: the functional programming
mindset.

#+texinfo:@subheading Chapter 6---Organizing your Project---A Librarian’s Tale

This chapter explains what namespaces are and how to use them to organize your
code.

#+texinfo:@subheading Chapter 7---Clojure Alchemy---Reading, Evaluation, and Macros

In this chapter, you’ll take a step back and describe how Clojure runs your
code.  This will give you the conceptual structure you need to truly understand
how Clojure works and how it’s different from other, non-Lisp languages.  With
this structure in place, I’ll introduce the macro, one of the most powerful
tools in existence.

#+texinfo:@subheading Writing Macros

This chapter thoroughly examines how to write macros, starting with basic
examples and advancing in complexity.

#+texinfo:@heading Part III---Advanced Topics

These chapters cover Clojure’s extra-fun topics---concurrency, Java interop and
abstraction.  Although you can write programs without understanding these tools
and concepts, they’re intellectually rewarding and give you tremendous power as
a programmer.  One of the reasons people say that learning Clojure makes you a
better programmer is that it makes the concepts covered in these chapters easy
to understand and practical to use.

#+texinfo:@subheading Chapter 9---The Sacred Art of Concurrent and Parallel Programming

In this chapter you’ll learn what concurrency and parallelism are and why they
matter.  You’ll learn about challenges you’ll face when writing parallel
programs and about how clojure’s design helps to mitigate them.  You’ll use
futures, delays, and promises to safely write parallel programs.

#+texinfo:@subheading Chapter 10---Clojure Metaphysics---Atoms, Refs, Vars, and Cuddle Zombies

This chapter goes into great detail about Clojure’s approach to managing state
and how that simplifies concurrent programmibng.  You’ll learn how to use
atoms, refs, and vars, three constructs for managing state, and you’ll learn
how to do stateless parallel computation with ~pmap~.  And there will be cuddle
zombies.

#+texinfo:@subheading Chapter 11---Mastering Concurrent Processes with ~core.async~

In this chapter, you’ll ponder the idea that everything in the univese is a hot
dog vending machine.  By which I mean you’ll learn how to model systems of
independently running processes that communicate with each other over channels
using the ~core.async~ library.

#+texinfo:@subheading Chapter 12---Working with the JVM

This chapter is like a phrase book and cultural introduction to the Land of
Java.  It gives you an overview of what the JVM is, how it runs programs, and
how to compile programs for it.  It also gives you a brief tour of frequently
used Java classes and methods, and explains how to interact with them from
Clojure.  It shows you how to think about and understand Java so you can
incorporate any Java library into your Clojure program.

#+texinfo:@subheading Chapter 13---Creating and Extending Abstractions with Multimethods, Protocols, and Records

This chapter serves as an introduction to the world of cereating and
implementing your own abstractions.  You’ll learn the basics of multimethods,
protocols, and records.

#+texinfo:@heading Appendix A---Building and Developing with Leiningen

This appendix clarifies some of the finer points of working with Leiningen,
like what Maven is and how to figure out the version numbers of Java libraries
so you can use them.

#+texinfo:@heading Appendix B---Boot, the Fancy Clojure Build Framework

Boot is an alternative to Leiningen that provides the same functionality, but
with the added bonus that its easier to extend and write composable tasks.
This appendix explains Boot’s underlying concepts and guides you through
writing your first tasks.

*** The Code

You can download all the source code from the book at
https://github.com/braveclojure/cftbat-code/.  The code is organized by
chapter.

Chapter 1 describes the different ways tht you can run Clojure code, including
how to use a REPL.  I recommend running most of the examples in the REPL as you
encounter them.  This will help you get used to writing and understanding Lisp
code, and it will help you retain everything you’re learning.  But for the
examples that are long, it’s best to write the code to a file, and then run the
code you wrote in a REPL.

*** The Journey Begins!

** Building---Running---and the REPL
:PROPERTIES:
:chapter:  1
:part:     I
:END:

In this chapter, you’ll invest a small amount of time up front to get familiar
with a quick, foolproof way to build and run Clojure programs.  It feels great
to get a real program running.  Reaching that milestone frees you up to
experiment, share your work, and gloat.

You’ll also learn how to instantly run code within a running Clojure process
using a /Read-Eval-Print Loop (REPL)/, which allows you to quickly test your
understanding of the language and learn more efficiently.

First, I’ll introduce you to Clojure.

Next, I’ll cover Leiningen, the de facto standard build tool for Clojure.

By the end of the chapter, you’ll know how to do the following:

- Create a new Clojure project with Leiningen

- Build the project to create an executable JAR file

- Execute the JAR file

- Execute code in a Clojure REPL

*** What is Clojure

When talking about Clojure, it’s important to keep in mind the distinction
between the Clojure language and the Clojure compiler.  The Clojure language is
a Lisp dialect with a functional emphasis whose syntax and semantics are
independent of any implementation.   The compiler is an executable JAR file,
~clojure.jar~, which takes code written in the Clojure language and compiles it
to a Java Virtual Machine (JVM) bytecode.

This distinction is necessary because, unlike most programming languages like
Ruby, Python, C, and others, Clojure is a /hosted language/.  Clojure programs
are executed within a JVM and rely on the JVM for core features like threading
and garbage collection.  Clojure also targets JavaScript and the Microsoft
Common Language runtime (CLR), but this book only focuses on the JVM
implementation.

For now the main concepts you need to understand are these:

#+cindex:@code{clojure.jar}
- JVM processes execute Java bytecode

- Usually, the Java Compiler produces Java bytecode from Java source code

- JAR files are collections of Java bytecode

- Java programs are usually distributed as JAR files

- The Java program ~clojure.jar~ reads Clojure source code and produces Java
  bytecode

- That Java bytecode is then executed by the same JVM process already running
  ~clojure.jar~

*** Leiningen


#+cindex:Leiningen
Most Clojurists use Leiningen to build and manage their projects.  For now
we’ll focus on using it for four tasks:

1. Creating a new Clojure project

2. Running the Clojure project

3. Building the Clojure project

4. Using the REPL


Before continuing, make sure you have Java version 1.6 or later installed.  You
can check your version by running:

#+cindex:java version
#+name:java-version
#+begin_src sh :results scalar :exports both
java -version 2>&1
#+end_src

#+cindex:@code{clojure.jar}
Install Leiningen using the instructions on the Leiningen home page at
http://leiningen.org.  When you install Leiningen, it automatically downloads
the Clojure compiler, ~clojure.jar~.

**** Creating a New Clojure Project

Creating a new Clojure project is very simple.  A single Leiningen command
creates a project skeleton.  Later, you’ll learn how to do tasks like
incorporate Clojure libraries.

Create your first Clojure project by typing the following in your terminal:

#+begin_src sh :eval no
lein new app clojure-noob
#+end_src

**** Running the Clojure Project

**** Building the Clojure Project

**** Using the REPL

*** Clojure Editors

*** Summary

** How to use Emacs
** Clojure Crash Course
** Core Functions in Depth
** Functional Programming
** Organizing Your Project
** Reading Evaluation and Macros
** Writing Macros
** Concurrent and Parallel Programming
** Atoms---Refs---Vars---Cuddle Zombies
** Mastering Concurrent Processes with core.async
** Working with the JVM
** Creating and Extending Abstractions with Multimethods-Protocols-and Records
** Building and Developing with Leiningen
** Boot---Clojure Build Framework
** Farewell

* About Leiningen

“for automating Clojure projects without setting your hair on fire”

Leiningen is the easiest way to use Clojure.  With a focus on project
automation and declarative configuration, it gets out of your way and lets you
focus on your code.

- [[https://leiningen.org][Leiningen Home]]

- [[https://github.com/technomancy/leiningen][Leiningen GitHub]]


Installed version:

#+begin_comment
The following code does not produce an output when this file is exported to
texinfo from the Makefile, but it does when exported from the export
dispatcher.  No idea why.
#+end_comment

#+name:lein-version
#+begin_src sh :results output verbatim :exports both
lein --version
#+end_src

#+begin_example
(defproject leiningen.org "1.0.0"
  :description "Generate static HTML for https://leiningen.org"
  :dependencies [[enlive "1.0.1"]
                 [cheshire "4.0.0"]
                 [org.markdownj/markdownj "0.3.0-1.0.2b4"]]
  :main leiningen.web)
#+end_example

** Leiningen Installation Instructions

#+cindex:Leiningen, install
#+cindex:OpenJDK
Leiningen and Clojure require Java.  OpenJDK version 8 is recommended at this
time.

#+cindex:lein script
1. Download the [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] (or on Windows =lein.bat=)

2. Place it on your =$PATH= where your shell can find it (eg. =~/bin=)

3. Set it to be executable (=chmod a+x ~/bin/lein=)

4. Run it (~lein~) and it will download the self-install package

** Leiningen Tutorial

#+cindex:Leiningen tutorial
#+cindex:tutorial
You can read the tutorial by running 
: lein help tutorial

- [[https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md][Tutorial on GitHub]]


Leiningen is for automating Clojure projects.  It offers various
project-related tasks and can:

- create new projects
- fetch dependencies for your project
- run tests
- run a fully-configured REPL
- compile Java sources (if any)
- run the project (if the project isn't a library)
- generate a maven-style "pom" file for the project for interop
- compile and package projects for deployment
- publish libraries to repositories such as Clojars
- run custom automation tasks written in Clojure (leiningen plug-ins)


#+texinfo:@heading What This Tutorial Covers

This tutorial will briefly cover
- project structure,
- dependency management,
- running tests,
- the REPL, and
- topics related to deployment.


This tutorial will help you get started and explain Leiningen's take on project
automation and JVM-land dependency management.

*** Leiningen Projects

#+cindex:project
Leiningen works with /projects/. 

#+cindex:@file{project.clj}
#+cindex:metadata
A /project/ is a directory containing a group of Clojure (and possibly Java)
source files, along with a bit of metadata about them.  The metadata is stored
in a file named ~project.clj~ in the project's root directory, which is how you
tell Leiningen about things like:

- Project name
- Project description
- What libraries the project depends on
- What Clojure version to use
- Where to find source files
- What's the main namespace of the app


Most Leiningen tasks only make sense in the context of a project.  Some (for
example, ~repl~ or ~help~) can also be called from any directory.

*** Creating a Leiningen Project

Generate a new project:
: lein new app <project-name>

#+begin_example
$ lein new app my-stuff

Generating a project called my-stuff based on the 'app' template.

$ cd my-stuff
$ find .
.
./.gitignore
./doc
./doc/intro.md
./LICENSE
./project.clj
./README.md
./resources
./src
./src/my_stuff
./src/my_stuff/core.clj
./test
./test/my_stuff
./test/my_stuff/core_test.clj
#+end_example

#+cindex:template
#+cindex:app template
#+cindex:default template
#+cindex:library
In this example we're using the =app= template, which is intended for an
application project rather than a library.  Omitting the =app= argument will
use the default template, which is suitable for libraries.

#+texinfo:@heading Directory Layout

#+cindex:app directory structure
#+cindex:project directory
#+cindex:namespace
Here we've got your project's README, a ~src/~ directory containing the code, a
~test/~ directory, and a ~project.clj~ file which describes your project to
Leiningen.  The ~src/my_stuff/core.clj~ file corresponds to the ~my-stuff.core~
/namespace/.

#+texinfo:@heading Filename-to-Namespace Mapping Convention

#+cindex:namespace
Note that we use ~my-stuff.core~ instead of just ~my-stuff~ since
single-segment namespaces are discouraged in Clojure.  Also note that
namespaces with dashes in the name will have the corresponding file named with
underscores instead since the JVM has trouble loading files with dashes in the
name.  The intricacies of namespaces are a common source of confusion for
newcomers, and while they are mostly outside the scope of this tutorial you can
[[https://8thlight.com/blog/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][read up on them elsewhere]].

#+texinfo:@heading @file{project.clj}

Your project.clj file will start off looking something like this:[fn:1]

#+begin_src clojure :eval no
(defproject my-stuff "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "https://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "https://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]]
  :main ^:skip-aot my-stuff.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
#+end_src

** Leiningen Documentation

#+cindex:documetation
#+cindex:FAQ
#+cindex:sample @file{project.clj}
- FAQ:
: lein help faq

- Documentation for each individual task:
: lein help $TASK

- See the sample ~project.clj~ file containing a reference of most project
  settings:
: lein help sample

** Leiningen Profiles

See https://github.com/technomancy/leiningen/blob/stable/doc/PROFILES.md

** Deploying Leiningen Projects

See https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md

** Leiningen Plugins

#+texinfo:@heading Writing Leiningen Plugins

See https://github.com/technomancy/leiningen/blob/stable/doc/PLUGINS.md

#+texinfo:@heading List of Leiningen Plugins

See https://github.com/technomancy/leiningen/wiki/Plugins

* About Clojure Mode

“Emacs support for the Clojure(Script) programming language”

- [[https://github.com/clojure-emacs/clojure-mode][Clojure Mode Home]]


Provides Emacs font-lock, indentation, navigation and refactoring for the
Clojure(Script) programming language.

** Clojure Mode Installation

Available on the major ~package.el~ community maintained repos:
- [[http://stable.melpa.org/][MELPA Stable]]
- [[http://melpa.org/][MELPA]]


MELPA Stable is the recommended repo as it has the latest stable version. MELPA
has a development snapshot for users who don't mind (infrequent) breakage but
don't want to run from a git checkout.

You can install ~clojure-mode~ using the following commands:

: M-x package-refresh-contents
: M-x package-install [RET] clojure-mode [RET]

or if you'd rather keep it in your dotfiles:

#+begin_src emacs-lisp :eval no
(unless (package-installed-p 'clojure-mode)
  (package-install 'clojure-mode))
#+end_src

#+texinfo:@heading Bundled major modes

The ~clojure-mode~ package actually bundles together several major modes:

- ~clojure-mode~ is a major mode for editing Clojure code

- ~clojurescript-mode~ is a major mode for editing ClojureScript code

- ~clojurec-mode~ is a major mode for editing ~.cljc~ source files


All the major modes derive from ~clojure-mode~ and provide more or less the
same functionality.  Differences can be found mostly in the font-locking ---
e.g. ClojureScript has some built-in constructs that are not present in
Clojure.

The proper major mode is selected automatically based on the extension of the
file you're editing.  Having separate major modes gives you the flexibility to
attach different hooks to them and to alter their behavior individually
(e.g. add extra font-locking just to ~clojurescript-mode~).  Note that all
modes derive from ~clojure-mode~, so things you add to ~clojure-mode-hook~ and
~clojure-mode-map~ will affect all the derived modes as well.

** Clojure Mode Configuration

In the spirit of Emacs, pretty much everything you can think of in
~clojure-mode~ is configurable.

To see a list of available configuration options do:
: M-x customize-group RET clojure.

*** Indentation Options

The default indentation rules in ~clojure-mode~ are derived from the community
Clojure Style Guide.  Please, refer to the guide for the general Clojure
indentation rules.

#+texinfo:@subheading Indentation of docstrings

By default multi-line docstrings are indented with 2 spaces, as this is a
somewhat common standard in the Clojure community.  You can however adjust this
by modifying ~clojure-docstring-fill-prefix-width~.  Set it to 0 if you don't
want multi-line docstrings to be indented at all (which is pretty common in
most lisps).

#+texinfo:@subheading Indentation of function forms

The indentation of function forms is configured by the variable
~clojure-indent-style~.  It takes three possible values:

- ~always-align~ (the default)

- ~always-indent~

- ~align-arguments~


#+texinfo:@subheading Indentation of macro forms

The indentation of special forms and macros with bodies is controlled via

- ~put-clojure-indent~, 

- ~define-clojure-indent~ and

- ~clojure-backtracking-indent~.


Nearly all special forms and built-in macros with bodies have special
indentation settings in ~clojure-mode~.  You can add/alter the indentation
settings in your personal config.  See
https://github.com/clojure-emacs/clojure-mode#indentation-of-macro-forms

#+texinfo:@subheading Vertical alignment

You can vertically align sexps with =C-c SPC=.

This can also be done automatically (as part of indentation) by turning on
~clojure-align-forms-automatically~.  This way it will happen whenever you
select some code and hit TAB.

*** Refactoring Support

The available refactorings were originally created and maintained by the
~clj-refactor.el~ team.  The ones implemented in Elisp only are gradually
migrated to ~clojure-mode~.

#+texinfo: @subheading Threading macros related features

See
https://github.com/clojure-emacs/clojure-mode#threading-macros-related-features

#+texinfo:@subheading Cycling things

See https://github.com/clojure-emacs/clojure-mode#cycling-things

#+texinfo:@subheading Convert collection

See https://github.com/clojure-emacs/clojure-mode#convert-collection

#+texinfo:@subheading Let expression

See https://github.com/clojure-emacs/clojure-mode#let-expression

#+texinfo:@subheading Rename ns alias

See https://github.com/clojure-emacs/clojure-mode#rename-ns-alias

#+texinfo:@subheading Add arity to a function

See https://github.com/clojure-emacs/clojure-mode#add-arity-to-a-function

*** Related Packages to Clojure Mode

See https://github.com/clojure-emacs/clojure-mode#related-packages

*** REPL Interaction in Clojure Mode

See https://github.com/clojure-emacs/clojure-mode#repl-interaction

A number of options exist for connecting to a running Clojure process and
evaluating code interactively.

- Basic REPL ::

  - [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] ::

    provides basic interaction with a Clojure REPL process.  It's
       very similar in nature and supported functionality to
       inferior-lisp-mode for Common Lisp.

- [[https://github.com/clojure-emacs/cider][CIDER]] ::

     a powerful Clojure interactive development environment, similar to SLIME
     for Common Lisp.

* About CIDER

“CIDER is the Clojure(Script) Interactive Development Environment that Rocks!”

- [[https://cider.mx][CIDER Home]]

- [[https://github.com/clojure-emacs/cider][CIDER GitHub]]


#+texinfo:@heading Overview

CIDER extends Emacs with support for interactive programming in Clojure.  The
features are centered around ~cider-mode~, an Emacs minor-mode that complements
~clojure-mode~.  While ~clojure-mode~ supports editing Clojure source files,
~cider-mode~ adds support for interacting with a running Clojure process for
compilation, debugging, definition and documentation lookup, running tests and
so on.

** CIDER Installation

The canonical way to install CIDER via Emacs's build-in package manager
(a.k.a. ~package.el~).  Assuming you've setup the required repository
(e.g. MELPA), all you need to do is:

: M-x package-install RET cider RET

** CIDER Quick Start

The simplest way to start CIDER is via =C-c C-x j j=.  This command will spin
an nREPL server and connect CIDER to it.

** CIDER Guide

See https://docs.cider.mx/cider/index.html

*** CIDER Overview

https://docs.cider.mx/cider/index.html

CIDER aims to provide an interactive development experience similar to the one
you’d get when programming in Emacs Lisp, Common Lisp (with SLIME or Sly),
Scheme (with Geiser) and Smalltalk.

Programmers are expected to program in a very dynamic and incremental manner,
constantly re-evaluating existing Clojure definitions and adding new ones to
their running applications.  You never stop/start a Clojure application while
using CIDER --- you’re constantly interacting with it and changing it.

You can find more details about the typical CIDER workflow in the [[https://docs.cider.mx/cider/usage/interactive_programming.html][Interactive
Programming]] section.  While we’re a bit short on video tutorials, you can check
out this [[https://www.youtube.com/watch?v=aYA4AAjLfT0][introduction to CIDER]] to get a feel about what do we mean by an
“Interactive Development Environment”.

#+cindex:nREPL
CIDER’s built on top of [[https://github.com/nrepl/nrepl][nREPL]], the Clojure networked REPL server.

Clojure code gets executed by an nREPL server.  CIDER sends requests to the
server and processes its responses.  The server’s functionality is augmented by
additional [[https://github.com/clojure-emacs/cider-nrepl][nREPL middleware]], designed specifically to address the needs of an
interactive development environment like CIDER.

*** CIDER Up and Running

https://docs.cider.mx/cider/basics/up_and_running.html

To use CIDER, you’ll need to connect it to a running nREPL server that is
associated with your program.  Most Clojure developers use standard build
tooling such as Leiningen, Boot, or Gradle, and CIDER can automatically work
with those tools to get you up and running quickly.  But those tools are not
required; CIDER can connect to an nREPL server that is already started and is
managed separately.[fn:2]

There are two ways to connect CIDER to an nREPL server:

1. CIDER can launch an nREPL server for your project from Emacs.

2. You can connect CIDER to an already-running nREPL server, managed
   separately.

**** Launch an nREPL Server From Emacs

https://docs.cider.mx/cider/basics/up_and_running.html#_launch_an_nrepl_server_from_emacs

#+cindex:nREPL session, launch
If you have a Clojure project in your file system and want CIDER to launch an
nREPL session for it, simply visit a file that belongs to the project, and type:

: M-x cider-jack-in RET

CIDER will start an nREPL server and automatically connect to it.

#+cindex:@code{cider-jack-in} command
In Clojure(Script) buffers the command ~cider-jack-in~ is bound to

: C-c C-x (C-)j (C-)j

The process of jacking-in is pretty simple:

- CIDER shells out and runs a command like ~lein repl :headless~.

- CIDER waits for the nREPL server to start.  CIDER figures out this by parsing
  the output from the command and waiting for a line like =nREPL server started
  on port 53005 on host localhost -- nrepl://localhost:53005= to appear there.

- CIDER extracts the port of the nREPL from the preceding message.

- It connects to the running nREPL server.


#+texinfo:@heading Auto-Injecting Dependencies

While CIDER’s core functionality requires nothing more than an nREPL server,
there are many advanced features that depend on the presence of additional
nREPL middleware.  In the early versions of CIDER (up to CIDER 0.11) users had
to add those dependencies themselves, which was a painful and error-prone
process.  Fortunately today that’s handled auto-magically when you’re using
~cider-jack-in~.

If your project uses ~lein~, ~boot~ or ~tools.deps~ (~deps.edn~), CIDER will
automatically inject all the necessary nREPL dependencies (e.g. ~cider-nrepl~
or ~piggieback~) when it starts the server.  The injection process is extremely
simple --- CIDER simply passes the extra dependencies and nREPL configuration
to your build tool in the command in runs to start the nREPL server.  Here’s
how this looks for ~tools.deps~:

#+begin_example
$ clojure -Sdeps '{:deps {nrepl {:mvn/version "0.6.0"} cider/cider-nrepl {:mvn/version "0.22.4"}}}' 
  -m nrepl.cmdline 
  --middleware '["cider.nrepl/cider-middleware"]'
#+end_example

Normally ~cider-jack-in~ would inject only ~cider-nrepl~ and
~cider-jack-in-cljs~ would add ~piggieback~ as well.  The injection mechanism
is configurable and you can easily add more libraries there.  Some CIDER
extensions would use this mechanism to auto-inject their own dependencies.

#+texinfo:@subheading Jacking-in without a Project

If you try to run ~cider-jack-in~ outside a project directory, CIDER will warn
you and ask you to confirm whether you really want to do this; more often than
not, this is an accident.  If you decide to proceed, CIDER will invoke the
command configured in ~cider-jack-in-default~.  Prior to CIDER 0.17, this
defaulted to ~lein~ but was subsequently switched to ~clj~, Clojure’s basic
startup command.

#+texinfo:@subheading Customizing the Jack-in Command Behaviour

You can use =C-u M-x cider-jack-in RET= to specify the exact command that
~cider-jack-in~ would run.  This option is very useful is you want to specify a
something like a ~lein~ or ~deps.edn~ profile.

Alternatively you can =C-u C-u M-x cider-jack-in RET=, which is a variation of
the previous command.  This command will first prompt you for the project you
want to launch ~cider-jack-in~ in, which is pretty handy if you’re in some
other directory currently.  This option is also useful if your project contains
some combination of ~project.clj~, ~build.boot~ and ~deps.edn~ and you want to launch
a REPL for one or the other.

**** Connect to a Running nREPL Server

https://docs.cider.mx/cider/basics/up_and_running.html#_connect_to_a_running_nrepl_server

If you have an nREPL server already running, CIDER can connect to it.  For
instance, if you have a Leiningen-based project, go to your project’s directory
in a terminal session and type:

: $ lein repl :headless

This will start the project’s nREPL server.

If your project uses boot, do this instead:

: $ boot repl -s wait (or whatever task launches a repl)

It is also possible for plain clj, although the command is somewhat longer:

: $ clj -Sdeps '{:deps {cider/cider-nrepl {:mvn/version "0.21.1"}}}'
:   -m nrepl.cmdline --middleware "[cider.nrepl/cider-middleware]"

Alternatively, you can start nREPL either manually or using the facilities
provided by your project’s build tool (Gradle, Maven, etc).

After you get your nREPL server running, go back to Emacs and connect to it:
=M-x cider-connect RET=.  CIDER will prompt you for the host and port
information, which should have been printed when the previous commands started
the nREPL server in your project.

In Clojure(Script) buffers the command cider-connect is bound to =C-c C-x c s=.

If you frequently connect to the same hosts and ports, you can tell CIDER about
them and it will use the information to do completing reads for the host and
port prompts when you invoke cider-connect. You can identify each host with an
optional label.

#+begin_src emacs-lisp :eval no
(setq cider-known-endpoints
  '(("host-a" "10.10.10.1" "7888")
    ("host-b" "7888")))
#+end_src

*** TODO CIDER Interactive Programming

https://docs.cider.mx/cider/usage/interactive_programming.html

** CIDER Features

#+texinfo:@heading Code Completion

CIDER provides smart code completion for Clojure and ClojureScript.

#+texinfo:@heading Enhanced REPL

CIDER provides a super-charged REPL experience with all the bells and whistles
you can imagine.

#+texinfo:@heading Definition and Documentation Lookup

CIDER provides powerful code and documentation lookup facilities.

#+texinfo:@heading Human-friendly Error Messages

CIDER tries to present Clojure's notorious stacktraces in a manner that's less
intimidating and more informative.

#+texinfo:@heading Interactive Debugger

CIDER tries to present Clojure's notorious stacktraces in a manner that's less
intimidating and more informative.

#+texinfo:@heading Test Integration

CIDER gives you the ability to run your tests without ever leaving your editor.

* Build Tools
:PROPERTIES:
:appendix: t
:END:
** Makefile
:PROPERTIES:
:appendix: t
:END:
#+name:Makefile
#+header: :tangle Makefile
#+header: :noweb tangle
#+begin_src makefile
  ### PROGRAM
  PROG   = <<get-org-filename()>>
  DIR    = <<get-org-lc-filename()>>
  VERS   = <<get-file-version()>>
  S3VERS = <<get-s3-version()>>

  ### TOOLS
  TOOLS = tools
  CMPRPL = $(TOOLS)/cmprpl

  ### TEXINFO
  ORG   = $(PROG).org
  TEXI  = $(PROG).texi
  INFO  = $(PROG).info
  PDF   = $(PROG).pdf
  HTML  = $(DIR)/index.html

  ### HTML DIR
  OLDDIR= $(DIR)-old
  INDEX = index.html

  ### AWS
  HOME = s3://$(AWS_BUCKET)
  AWS  = aws2
  S3   = $(AWS) s3
  SRC  = $(DIR)/

  DST_OLD = $(HOME)/$(DIR)-$(S3VERS)
  DST_NEW = $(HOME)/$(DIR)-$(VERS)
  EXCL_INCL = --exclude "*" --include "*.html"
  GRANTS = --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  REGION = --region us-west-2
  S3SYNC = $(S3) sync $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE = $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)

  default: texi info html pdf

  PHONY: default all texi info html pdf open-org open-texi open-html \
	   open-pdf clean clean-dist help sync

  show-version:
	  @echo EMACSLOADPATH $(EMACSLOADPATH)
	  @echo AWS_BUCKET $(AWS_BUCKET)
	  @echo PROG $(PROG)
	  @echo VERS $(VERS)
	  @echo S3VERS $(S3VERS)
	  @echo DIR $(DIR)
	  @echo OLDDIR $(OLDDIR)
	  @echo SRC $(SRC)
	  @echo DST_OLD $(DST_OLD)
	  @echo DST_NEW $(DST_NEW)

  open-org: $(ORG)
	  emacsclient $(ORG) &
  $(ORG):
	  @echo 'DISASTER HAS BEFALLEN YOU AS THERE IS NO $(ORG) FILE!!!'
	  exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	  /Applications/MacPorts/EmacsMac.app/Contents/MacOS/bin/emacs --batch --eval '\
	  (progn \
	    (setq org-export-backends (quote (texinfo))) \
	    (require (quote org)) \
	    (require (quote ob)) \
	    (require (quote ob-shell)) \
	    (require (quote ob-clojure)) \
	    (setq org-confirm-babel-evaluate nil) \
	    (find-file "$(ORG)") \
	    (org-export-to-file (quote texinfo) "$(TEXI)"))'

  open-texi: texi
	  emacsclient $(TEXI) &

  info: $(INFO)
  $(INFO): $(TEXI)
	  makeinfo $(TEXI)

  html: $(HTML)
  $(HTML): $(TEXI)
	  makeinfo --html $(TEXI)
	  $(CMPRPL) $(DIR) $(OLDDIR)
  open-html: html
	  open $(HTML)

  pdf: $(PDF)
  $(PDF): $(TEXI)
	  pdftexi2dvi --quiet --build=clean $(TEXI)
  open-pdf: pdf
	  open $(PDF)

  sync: $(HTML)
	  $(S3SYNC)
	  [[ $(VERS) != $(S3VERS) ]] && $(S3MOVE) || :

  clean:
	  -rm *~

  clean-dist: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)

  help:
	  @echo '"make default" makes the .texi file \
	  the html files, and opens the index.html file'
	  @echo

	  @echo '"make all" makes the .texi, .info, .pdf, and html distribution'
	  @echo '"make sync" syncs the html files in the AWS S3 bucket HOME; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make clean-dist" cleans, removes the html distribution, \
	  and removes the build directory'

#+end_src
** Get Org Filename
This program simply uses the name of the buffer to obtain the name of the
filename to add to the Makefile.

#+caption:Get Org Filename program
#+name:get-org-filename
#+begin_src emacs-lisp :eval yes
(file-name-base)
#+end_src

** Get Org Lowercase Filename
This program simply downcases the buffer filename to use as a directory name
for the HTML output.

#+caption:Get Org Lowercase Filename program
#+name:get-org-lc-filename
#+begin_src emacs-lisp :eval yes
(downcase (file-name-base))
#+end_src

** Get File Version
This program scans the current buffer for the version number and places it into
the Makefile.

#+caption:Get File Version program
#+name:get-file-version
#+begin_src emacs-lisp :eval yes
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^#\\+macro:version Version \\(\\(?:[[:digit:]]+\\.?\\)\\{3\\}\\)")
    (concat "v" (match-string-no-properties 1) "/"))
#+end_src

** Get S3 Version
:PROPERTIES:
:dependency: ">= bash v4"
:END:
This program obtains the version number of the code currently uploaded to the
S3 bucket by obtaining a directly listing of top-level directories, which are
in the form ~PRE <dir>-v#.#.#/~, and performs a regular expression search with
a parenthesized match on the version numbers.  The program will exit with an
error if there is no match, but will return the version number as a string if
there is a match.

Note that the regular expression matching requires at least Bash version 4 or
above.

#+caption:Get S3 Version
#+name:get-s3-version
#+header: :results output
#+header: :var dir=get-org-lc-filename()
#+header: :var file_version=get-file-version()
#+begin_src sh :eval yes
  [[ ${file_version} = v0.0.0/ ]] && { echo "nil"; exit 0; } || :
  re=${dir}'-(v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)'
  verpre=$(aws2 s3 ls s3://pinecone-forest.com/) ### TODO
  [[ $verpre =~ $re ]] && : || { echo "nil"; exit 0; }
  ver=${BASH_REMATCH[1]}
  echo "${ver}"
#+end_src

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.  This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=, as this directory is deleted upon a
~make clean-dist~.  It also makes sure there is a Makefile on an initial
export, although the Makefile is never thereafter deleted.  The following code
is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: $NEWDIR.  If it
doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, $OLDDIR.  If one doesn’t,
then one is created by copying the current new directory.  This provides a
baseline for comparisons going forward.

The program then loops through all of the files in the new directory and copies
any that do not exist in the old directory.  Now both directories should be in
sync.

It is important to retain the $OLDDIR for as long as possible to reap the most
benefits from the AWS S3 ~sync~ command.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl :eval no-export
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  NEWDIR=$1
  OLDDIR=$2

  [[ -d $NEWDIR ]] || { echo "ERROR: $NEWDIR does not exist"; exit 1; }
  [[ -d $OLDDIR ]] || { echo "CREATING: $OLDDIR does not exist"; cp -a $NEWDIR $OLDDIR; exit 0; }

  for oldfile in $OLDDIR/*
  do
      newfile=$NEWDIR/$(basename $oldfile)
      if [[ -e $newfile ]]
      then
	      if cmp -s $newfile $oldfile
	      then
	          printf "${GREEN}copying OLD to NEW${CLEAR}: "
	          cp -vp $oldfile $newfile
	      else
	          printf "${MAGENTA}copying NEW to OLD${CLEAR}: "
	          cp -vp $newfile $oldfile
	      fi
      else
	      printf "${RED}removing OLD:${CLEAR} "
	      rm -v $oldfile
      fi
  done

  for newfile in $NEWDIR/*
  do
      oldfile=$OLDDIR/$(basename $newfile)
      [[ -e $oldfile ]] || { printf "${BLUE}copying NEW to OLD${CLEAR}: "
			     cp -vp $newfile $oldfile; }
  done
#+end_src


* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:


* Export Configurations                                            :noexport:
#+texinfo_filename:clojure.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Programming Languages
#+texinfo_dir_title:Clojure
#+texinfo_dir_desc:All about the elegant language of Clojure
#+texinfo_printed_title:All About Clojure


* Local Variables                                                  :noexport:

* Footnotes

[fn:1]Org requires [[https://github.com/clojure-emacs/clojure-mode][Clojure-mode]] to work with clojure source code.  Clojure mode
provides Emacs font-lock, indentation, navigation and refactoring for the
Clojure(Script) programming language.



[fn:2]CIDER will automatically work with Leiningen 2.9.0+ or Boot 2.8.3+.
Older versions are not supported.
# Local Variables:
# fill-column: 79
# indent-tabs-mode: t
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (electric-quote-local-mode t)
# End:
