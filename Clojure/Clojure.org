# -*- mode:org; -*-

#+title:Clojure
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-01-09 08:36
#+macro:version Version 0.0.6

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying


* Introduction to Clojure
:PROPERTIES:
:unnumbered: t
:END:

“Clojure is a robust, practical, and fast programming language with a set of
useful features that together form a simple, coherent, and powerful tool.”

- [[https://clojure.org][Clojure Home]]

- [[https://clojure.org/reference/reader][Clojure Reference]]

- [[https://clojure.org/api/api][Clojure API]]

- [[https://clojure.org/guides/getting_started][Clojure Guides]]


Clojure is a dynamic, general-purpose programming language, combining the
approachability and interactive development of a scripting language with an
efficient and robust infrastructure for multithreaded programming.  Clojure is
a compiled language, yet remains completely dynamic --- every feature supported
by Clojure is supported at runtime.  Clojure provides easy access to the Java
frameworks, with optional type hints and type inference, to ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language, and features a rich set of immutable, persistent data structures.
When mutable state is needed, Clojure offers a software transactional memory
system and reactive Agent system that ensure clean, correct, multithreaded
designs.

** Clojure Features

#+texinfo:@heading Dynamic Development

Clojure is a dynamic environment you can interact with.  Almost all of the
language constructs are reified, and thus can be examined and changed.  You can
grow your program, with data loaded, adding features, fixing bugs, testing, in
an unbroken stream.

#+texinfo:@heading LISP

Clojure is a member of the Lisp family of languages.  Many of the features of
Lisp have made it into other languages, but Lisp's approach to code-as-data and
its macro system still set it apart.  Additionally, Clojure’s maps, sets, and
vectors are as first class in Clojure as lists are in Lisp.

#+texinfo:@heading Concurrent Programming

Clojure simplifies multi-threaded programming in several ways.  Because the
core data structures are immutable, they can be shared readily between threads.
Clojure, being a practical language, allows state to change but provides
mechanism to ensure that, when it does so, it remains consistent, while
alleviating developers from having to avoid conflicts manually using locks etc.

#+texinfo:@heading Functional Programming

Clojure provides the tools to avoid mutable state, provides functions as
first-class objects, and emphasizes recursive iteration instead of side-effect
based looping.  Clojure is impure, yet stands behind the philosophy that
programs that are more functional are more robust.

#+texinfo:@heading Runtime Polymorphism

Systems that utilize runtime polymorphism are easier to change and extend.
Clojure offers simple, powerful and flexible mechanisms for runtime
polymorphism.  Clojure’s protocols and datatypes features add mechanisms for
abstraction and data structure definition with no compromises vs the facilities
of the host platform.

#+texinfo:@heading Hosted on the JVM

Clojure is designed to be a hosted language, sharing the JVM type system, GC,
threads etc.  All functions are compiled to JVM bytecode.  Clojure is a great
Java library consumer, offering the dot-target-member notation for calls to
Java.  Clojure supports the dynamic implementation of Java interfaces and
classes.

* Clojure for Brave and True
:PROPERTIES:
:url: https://www.braveclojure.com
:author:   "Daniel Higginbotham"
:author-blog: http://flyingmachinestudios.com
:reviewer-blog: http://tailrecursion.com/~alan
:copyright: 2015
:publisher: "No Starch Press"
:isbn:     1-59327-591-9
:isbn-13:  978-1-59327-591-4
:END:

** Forward
#+cindex:John McCarthy
#+cindex:Lisp
You will eventually learn through reading this book that programming is more
enjoyable after knowing some Clojure.  Clojure is the most elegant programming
language every designed.  Elegance is a quality regularly ascribed to many
dialects in the family of programming languages known collectively as Lisp, or
which Clojure is one.   All Lisps descend from a set of siimple and beautiful
discoveries made by the mathematician John McCarthy in 1958.

** Introduction
:PROPERTIES:
:unnumbered: t
:END:

*** Learning a New Programming Language---A Journey through the Four Labyrinths
To wield Clojure to its fullest, you’ll need to find your way through the four
labyrinths that face every programmer learning a new language:

#+attr_texinfo: :indic b
- The Forest of Tooling ::

     A friendly and efficient programming environment makes it easy to try your
     ideas.  You’ll learn how to set up your environment.

- The Mountain of Language ::

     As you ascend, you’ll gain knowledge of Clojure’s syntax, semantics, and
     data structures.  You’ll learn how to use one of the mightiest programming
     tools, the macro, and learn how to simplify your life with Clojure’s
     concurrency constraints.

- The Cave of Artifacts ::

     In its depths, you’ll learn to build, run, and distribute your own
     programs, and how to use code libraries.  You’ll also learn Clojure’s
     relationship to the Java Virtual Machine (JVM).

- The Cloud Castle of Mindset ::

     In its rarefied air, you’ll come to know they why and how of Lisp and
     functional programming.  You’ll learn about the philosophy of simplicity
     that permeates Clojure, and how to solve problems like a Clojurist.


This book follows three guidelines:

1. It takes the dessert-first approach, giving you the development tools and
   language details you need to start playing with real programs immediately.

2. It assumes zero experience with the JVM, functional programming, or Lisp.
   It covers these topics in detail so you’ll feel confident about what you’re
   doing when you build and run Clojure programs.

3. It eschews /real-world/ examples in favor of more interesting exercises,
   like /assaulting hobbits/ and /tracking glittery vampires/.


By the end, you’ll be able to use Clojure.

*** How this Book is Organized

This book is split into three parts to better guide you through your valient
quest, brave fledgling Clojurist.

#+texinfo:@heading Part I---Environment Setup

Theswe chapters take you on a quick tour of the tools you’ll need to easily
write programs.

#+texinfo:@subheading Chapter 1---Building-Running-and the REPL

There’s something powerful and motivating about getting a real program
running.  Once you can do that, you’re free to experiment, and you can actually
share your work!

In this chapter, you’ll invest a small amount of time to become familiar with a
quick way to build and run Clojure programs.  You’ll learn how to experiment
with code in a running Clojure process using a read-eval-print loop (REPL).
This will tighten your feedback loop and help you learn more efficiently.

#+texinfo:@subheading How to use Emacs---an excellent Clojure Editor

A quick feedback loop is crucial for learning.  In this chapter, I cover Emacs
from the ground up to guarantee you have an efficient Emacs/Clojure workflow.

#+texinfo:@heading Part II---Language Fundamentals

These chapters give you a solid foundation on which to continue learning
Clojure.  You’ll start by learning Clojure’s basics (syntax, semantics, and
data structures) so you can /do things/.  Then you’ll take a step back to
examine Clojure’s most used functions in detail and learn how to solve problems
with them using the /functional programming/ mindset.

#+texinfo:@subheading Chapter 3---Do Things---a Clojure Crash Course

Clojure’s most salient characteristic is that it is a Lisp.  You’ll explore
this Lisp core, which is composed of two parts: functions and data.

#+texinfo:@subheading Chapter 4---Core Functions in Depth

In this chapter you’ll learn about a couple of Clojure’s underlying concepts.
This will give you the grounding you need to read the documentation for
functions you haven’t used before and to understand what’s happening when you
try them.

You’ll also see usage examples of the functions you’ll be reading for the
most.  This will give you a solid foundation for writing your own code and for
reading and learning from other people’s projects.

#+texinfo:@subheading Chapter 5---Functional Programming

In this chapter, you’ll take your concrete experience with functions and data
structures and integrate it with a new mindset: the functional programming
mindset.

#+texinfo:@subheading Chapter 6---Organizing your Project---A Librarian’s Tale

This chapter explains what namespaces are and how to use them to organize your
code.

#+texinfo:@subheading Chapter 7---Clojure Alchemy---Reading, Evaluation, and Macros

In this chapter, you’ll take a step back and describe how Clojure runs your
code.  This will give you the conceptual structure you need to truly understand
how Clojure works and how it’s different from other, non-Lisp languages.  With
this structure in place, I’ll introduce the macro, one of the most powerful
tools in existence.

#+texinfo:@subheading Writing Macros

This chapter thoroughly examines how to write macros, starting with basic
examples and advancing in complexity.

#+texinfo:@heading Part III---Advanced Topics

These chapters cover Clojure’s extra-fun topics---concurrency, Java interop and
abstraction.  Although you can write programs without understanding these tools
and concepts, they’re intellectually rewarding and give you tremendous power as
a programmer.  One of the reasons people say that learning Clojure makes you a
better programmer is that it makes the concepts covered in these chapters easy
to understand and practical to use.

#+texinfo:@subheading Chapter 9---The Sacred Art of Concurrent and Parallel Programming

In this chapter you’ll learn what concurrency and parallelism are and why they
matter.  You’ll learn about challenges you’ll face when writing parallel
programs and about how clojure’s design helps to mitigate them.  You’ll use
futures, delays, and promises to safely write parallel programs.

#+texinfo:@subheading Chapter 10---Clojure Metaphysics---Atoms, Refs, Vars, and Cuddle Zombies

This chapter goes into great detail about Clojure’s approach to managing state
and how that simplifies concurrent programmibng.  You’ll learn how to use
atoms, refs, and vars, three constructs for managing state, and you’ll learn
how to do stateless parallel computation with ~pmap~.  And there will be cuddle
zombies.

#+texinfo:@subheading Chapter 11---Mastering Concurrent Processes with ~core.async~

In this chapter, you’ll ponder the idea that everything in the univese is a hot
dog vending machine.  By which I mean you’ll learn how to model systems of
independently running processes that communicate with each other over channels
using the ~core.async~ library.

#+texinfo:@subheading Chapter 12---Working with the JVM

This chapter is like a phrase book and cultural introduction to the Land of
Java.  It gives you an overview of what the JVM is, how it runs programs, and
how to compile programs for it.  It also gives you a brief tour of frequently
used Java classes and methods, and explains how to interact with them from
Clojure.  It shows you how to think about and understand Java so you can
incorporate any Java library into your Clojure program.

#+texinfo:@subheading Chapter 13---Creating and Extending Abstractions with Multimethods, Protocols, and Records

This chapter serves as an introduction to the world of cereating and
implementing your own abstractions.  You’ll learn the basics of multimethods,
protocols, and records.

#+texinfo:@heading Appendix A---Building and Developing with Leiningen

This appendix clarifies some of the finer points of working with Leiningen,
like what Maven is and how to figure out the version numbers of Java libraries
so you can use them.

#+texinfo:@heading Appendix B---Boot, the Fancy Clojure Build Framework

Boot is an alternative to Leiningen that provides the same functionality, but
with the added bonus that its easier to extend and write composable tasks.
This appendix explains Boot’s underlying concepts and guides you through
writing your first tasks.

*** The Code

You can download all the source code from the book at
https://github.com/braveclojure/cftbat-code/.  The code is organized by
chapter.

Chapter 1 describes the different ways tht you can run Clojure code, including
how to use a REPL.  I recommend running most of the examples in the REPL as you
encounter them.  This will help you get used to writing and understanding Lisp
code, and it will help you retain everything you’re learning.  But for the
examples that are long, it’s best to write the code to a file, and then run the
code you wrote in a REPL.

*** The Journey Begins!

** Building---Running---and the REPL
:PROPERTIES:
:chapter:  1
:part:     I
:END:

In this chapter, you’ll invest a small amount of time up front to get familiar
with a quick, foolproof way to build and run Clojure programs.  It feels great
to get a real program running.  Reaching that milestone frees you up to
experiment, share your work, and gloat.

You’ll also learn how to instantly run code within a running Clojure process
using a /Read-Eval-Print Loop (REPL)/, which allows you to quickly test your
understanding of the language and learn more efficiently.

First, I’ll introduce you to Clojure.

Next, I’ll cover Leiningen, the de facto standard build tool for Clojure.

By the end of the chapter, you’ll know how to do the following:

- Create a new Clojure project with Leiningen

- Build the project to create an executable JAR file

- Execute the JAR file

- Execute code in a Clojure REPL

*** What is Clojure

When talking about Clojure, it’s important to keep in mind the distinction
between the Clojure language and the Clojure compiler.  The Clojure language is
a Lisp dialect with a functional emphasis whose syntax and semantics are
independent of any implementation.   The compiler is an executable JAR file,
~clojure.jar~, which takes code written in the Clojure language and compiles it
to a Java Virtual Machine (JVM) bytecode.

This distinction is necessary because, unlike most programming languages like
Ruby, Python, C, and others, Clojure is a /hosted language/.  Clojure programs
are executed within a JVM and rely on the JVM for core features like threading
and garbage collection.  Clojure also targets JavaScript and the Microsoft
Common Language runtime (CLR), but this book only focuses on the JVM
implementation.

For now the main concepts you need to understand are these:

#+cindex:@code{clojure.jar}
- JVM processes execute Java bytecode

- Usually, the Java Compiler produces Java bytecode from Java source code

- JAR files are collections of Java bytecode

- Java programs are usually distributed as JAR files

- The Java program ~clojure.jar~ reads Clojure source code and produces Java
  bytecode

- That Java bytecode is then executed by the same JVM process already running
  ~clojure.jar~

*** Leiningen


#+cindex:Leiningen
Most Clojurists use Leiningen to build and manage their projects.  For now
we’ll focus on using it for four tasks:

1. Creating a new Clojure project

2. Running the Clojure project

3. Building the Clojure project

4. Using the REPL


Before continuing, make sure you have Java version 1.6 or later installed.  You
can check your version by running:

#+cindex:java version
#+begin_src sh :results output :exports both
java --version
#+end_src

#+RESULTS:
: java 11 2018-09-25
: Java(TM) SE Runtime Environment 18.9 (build 11+28)
: Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)

#+cindex:@code{clojure.jar}
Install Leiningen using the instructions on the Leiningen home page at
http://leiningen.org.  When you install Leiningen, it automatically downloads
the Clojure compiler, ~clojure.jar~.

**** Creating a New Clojure Project

Creating a new Clojure project is very simple.  A single Leiningen command
creates a project skeleton.  Later, you’ll learn how to do tasks like
incorporate Clojure libraries.

Create your first Clojure project by typing the following in your terminal:

#+begin_src sh
lein new app clojure-noob
#+end_src

#+RESULTS:

**** Running the Clojure Project

**** Building the Clojure Project

**** Using the REPL

*** Clojure Editors

*** Summary

** How to use Emacs
** Clojure Crash Course
** Core Functions in Depth
** Functional Programming
** Organizing Your Project
** Reading Evaluation and Macros
** Writing Macros
** Concurrent and Parallel Programming
** Atoms---Refs---Vars---Cuddle Zombies
** Mastering Concurrent Processes with core.async
** Working with the JVM
** Creating and Extending Abstractions with Multimethods-Protocols-and Records
** Building and Developing with Leiningen
** Boot---Clojure Build Framework
** Farewell

* About Leiningen

“for automating Clojure projects without setting your hair on fire”

Leiningen is the easiest way to use Clojure.  With a focus on project
automation and declarative configuration, it gets out of your way and lets you
focus on your code.

- [[https://leiningen.org][Leiningen Home]]

- [[https://github.com/technomancy/leiningen][Leiningen GitHub]]

- Installed version:
  - src_sh[:results scalar :exports results]{lein --version}


#+begin_example
(defproject leiningen.org "1.0.0"
  :description "Generate static HTML for https://leiningen.org"
  :dependencies [[enlive "1.0.1"]
                 [cheshire "4.0.0"]
                 [org.markdownj/markdownj "0.3.0-1.0.2b4"]]
  :main leiningen.web)
#+end_example

** Leiningen Installation Instructions

#+cindex:Leiningen, install
#+cindex:OpenJDK
Leiningen and Clojure require Java.  OpenJDK version 8 is recommended at this
time.

#+cindex:lein script
1. Download the [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] (or on Windows =lein.bat=)

2. Place it on your =$PATH= where your shell can find it (eg. =~/bin=)

3. Set it to be executable (=chmod a+x ~/bin/lein=)

4. Run it (~lein~) and it will download the self-install package

** Leiningen Tutorial

#+cindex:Leiningen tutorial
#+cindex:tutorial
You can read the tutorial by running 
: lein help tutorial

- [[https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md][Tutorial on GitHub]]


Leiningen is for automating Clojure projects.  It offers various
project-related tasks and can:

- create new projects
- fetch dependencies for your project
- run tests
- run a fully-configured REPL
- compile Java sources (if any)
- run the project (if the project isn't a library)
- generate a maven-style "pom" file for the project for interop
- compile and package projects for deployment
- publish libraries to repositories such as Clojars
- run custom automation tasks written in Clojure (leiningen plug-ins)


#+texinfo:@heading What This Tutorial Covers

This tutorial will briefly cover
- project structure,
- dependency management,
- running tests,
- the REPL, and
- topics related to deployment.


This tutorial will help you get started and explain Leiningen's take on project
automation and JVM-land dependency management.

*** Leiningen Projects

#+cindex:project
Leiningen works with /projects/. 

#+cindex:@file{project.clj}
#+cindex:metadata
A /project/ is a directory containing a group of Clojure (and possibly Java)
source files, along with a bit of metadata about them.  The metadata is stored
in a file named ~project.clj~ in the project's root directory, which is how you
tell Leiningen about things like:

- Project name
- Project description
- What libraries the project depends on
- What Clojure version to use
- Where to find source files
- What's the main namespace of the app


Most Leiningen tasks only make sense in the context of a project.  Some (for
example, ~repl~ or ~help~) can also be called from any directory.

*** Creating a Leiningen Project

Generate a new project:
: lein new app <project-name>

#+begin_example
$ lein new app my-stuff

Generating a project called my-stuff based on the 'app' template.

$ cd my-stuff
$ find .
.
./.gitignore
./doc
./doc/intro.md
./LICENSE
./project.clj
./README.md
./resources
./src
./src/my_stuff
./src/my_stuff/core.clj
./test
./test/my_stuff
./test/my_stuff/core_test.clj
#+end_example

#+cindex:template
#+cindex:app template
#+cindex:default template
#+cindex:library
In this example we're using the =app= template, which is intended for an
application project rather than a library.  Omitting the =app= argument will
use the default template, which is suitable for libraries.

#+texinfo:@heading Directory Layout

#+cindex:app directory structure
#+cindex:project directory
#+cindex:namespace
Here we've got your project's README, a ~src/~ directory containing the code, a
~test/~ directory, and a ~project.clj~ file which describes your project to
Leiningen.  The ~src/my_stuff/core.clj~ file corresponds to the ~my-stuff.core~
/namespace/.

#+texinfo:@heading Filename-to-Namespace Mapping Convention

#+cindex:namespace
Note that we use ~my-stuff.core~ instead of just ~my-stuff~ since
single-segment namespaces are discouraged in Clojure.  Also note that
namespaces with dashes in the name will have the corresponding file named with
underscores instead since the JVM has trouble loading files with dashes in the
name.  The intricacies of namespaces are a common source of confusion for
newcomers, and while they are mostly outside the scope of this tutorial you can
[[https://8thlight.com/blog/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][read up on them elsewhere]].

#+texinfo:@heading @file{project.clj}

Your project.clj file will start off looking something like this:[fn:1]

#+begin_src clojure :eval no
(defproject my-stuff "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "https://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "https://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]]
  :main ^:skip-aot my-stuff.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
#+end_src

** Leiningen Documentation

#+cindex:documetation
#+cindex:FAQ
#+cindex:sample @file{project.clj}
- FAQ:
: lein help faq

- Documentation for each individual task:
: lein help $TASK

- See the sample ~project.clj~ file containing a reference of most project
  settings:
: lein help sample

** Leiningen Profiles

See https://github.com/technomancy/leiningen/blob/stable/doc/PROFILES.md

** Deploying Leiningen Projects

See https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md

** Leiningen Plugins

#+texinfo:@heading Writing Leiningen Plugins

See https://github.com/technomancy/leiningen/blob/stable/doc/PLUGINS.md

#+texinfo:@heading List of Leiningen Plugins

See https://github.com/technomancy/leiningen/wiki/Plugins

* Build Tools
:PROPERTIES:
:appendix: t
:END:
** Makefile
:PROPERTIES:
:appendix: t
:END:
#+name:Makefile
#+header: :tangle Makefile
#+header: :noweb tangle
#+begin_src makefile
  ### PROGRAM
  PROG   = <<get-org-filename()>>
  DIR    = <<get-org-lc-filename()>>
  VERS   = <<get-file-version()>>
  S3VERS = <<get-s3-version()>>

  ### TOOLS
  TOOLS = tools
  CMPRPL = $(TOOLS)/cmprpl

  ### TEXINFO
  ORG   = $(PROG).org
  TEXI  = $(PROG).texi
  INFO  = $(PROG).info
  PDF   = $(PROG).pdf
  HTML  = $(DIR)/index.html

  ### HTML DIR
  OLDDIR= $(DIR)-old
  INDEX = index.html

  ### AWS
  HOME = s3://$(AWS_BUCKET)
  AWS  = aws2
  S3   = $(AWS) s3
  SRC  = $(DIR)/

  DST_OLD = $(HOME)/$(DIR)-$(S3VERS)
  DST_NEW = $(HOME)/$(DIR)-$(VERS)
  EXCL_INCL = --exclude "*" --include "*.html"
  GRANTS = --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  REGION = --region us-west-2
  S3SYNC = $(S3) sync $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE = $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)

  default: texi info html pdf

  PHONY: default all texi info html pdf open-org open-texi open-html \
	   open-pdf clean clean-dist help sync

  show-version:
	  @echo EMACSLOADPATH $(EMACSLOADPATH)
	  @echo AWS_BUCKET $(AWS_BUCKET)
	  @echo PROG $(PROG)
	  @echo VERS $(VERS)
	  @echo S3VERS $(S3VERS)
	  @echo DIR $(DIR)
	  @echo OLDDIR $(OLDDIR)
	  @echo SRC $(SRC)
	  @echo DST_OLD $(DST_OLD)
	  @echo DST_NEW $(DST_NEW)

  open-org: $(ORG)
	  emacsclient $(ORG) &
  $(ORG):
	  @echo 'DISASTER HAS BEFALLEN YOU AS THERE IS NO $(ORG) FILE!!!'
	  exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	  emacs --batch --eval '\
	  (progn \
	    (require '\''org) \
	    (require '\''ob) \
	    (require '\''ox-texinfo) \
	    (require '\''ob-shell) \
	    (setq org-confirm-babel-evaluate nil) \
	    (find-file "$(ORG)") \
	    (org-export-to-file '\''texinfo "$(TEXI)"))'

  open-texi: texi
	  emacsclient $(TEXI) &

  info: $(INFO)
  $(INFO): $(TEXI)
	  makeinfo $(TEXI)

  html: $(HTML)
  $(HTML): $(TEXI)
	  makeinfo --html $(TEXI)
	  $(CMPRPL) $(DIR) $(OLDDIR)
  open-html: html
	  open $(HTML)

  pdf: $(PDF)
  $(PDF): $(TEXI)
	  pdftexi2dvi --quiet --build=clean $(TEXI)
  open-pdf: pdf
	  open $(PDF)

  sync: $(HTML)
	  $(S3SYNC)
	  [[ $(VERS) != $(S3VERS) ]] && $(S3MOVE) || :

  clean:
	  -rm *~

  clean-dist: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)

  help:
	  @echo '"make default" makes the .texi file \
	  the html files, and opens the index.html file'
	  @echo

	  @echo '"make all" makes the .texi, .info, .pdf, and html distribution'
	  @echo '"make sync" syncs the html files in the AWS S3 bucket HOME; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make clean-dist" cleans, removes the html distribution, \
	  and removes the build directory'

#+end_src
** Get Org Filename
This program simply uses the name of the buffer to obtain the name of the
filename to add to the Makefile.

#+caption:Get Org Filename program
#+name:get-org-filename
#+begin_src emacs-lisp :eval yes
(file-name-base)
#+end_src

** Get Org Lowercase Filename
This program simply downcases the buffer filename to use as a directory name
for the HTML output.

#+caption:Get Org Lowercase Filename program
#+name:get-org-lc-filename
#+begin_src emacs-lisp :eval yes
(downcase (file-name-base))
#+end_src

** Get File Version
This program scans the current buffer for the version number and places it into
the Makefile.

#+caption:Get File Version program
#+name:get-file-version
#+begin_src emacs-lisp :eval yes
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^#\\+macro:version Version \\(\\(?:[[:digit:]]+\\.?\\)\\{3\\}\\)")
    (concat "v" (match-string-no-properties 1) "/"))
#+end_src

** Get S3 Version
:PROPERTIES:
:dependency: ">= bash v4"
:END:
This program obtains the version number of the code currently uploaded to the
S3 bucket by obtaining a directly listing of top-level directories, which are
in the form ~PRE <dir>-v#.#.#/~, and performs a regular expression search with
a parenthesized match on the version numbers.  The program will exit with an
error if there is no match, but will return the version number as a string if
there is a match.

Note that the regular expression matching requires at least Bash version 4 or
above.

#+caption:Get S3 Version
#+name:get-s3-version
#+header: :var dir=get-org-lc-filename()
#+header: :var file_version=get-file-version()
#+begin_src sh :eval yes
  [[ ${file_version} = v0.0.0/ ]] && { echo "nil"; exit 0; }
  re=${dir}'-(v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)'
  verpre=$(aws2 s3 ls s3://pinecone-forest.com/) ### TODO
  [[ $verpre =~ $re ]] && : || { printf "${RED} ERROR get-s3-version: no match${CLEAR}"; exit 1; }
  ver=${BASH_REMATCH[1]}
  echo "${ver}"
#+end_src

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.  This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=, as this directory is deleted upon a
~make clean-dist~.  It also makes sure there is a Makefile on an initial
export, although the Makefile is never thereafter deleted.  The following code
is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: $NEWDIR.  If it
doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, $OLDDIR.  If one doesn’t,
then one is created by copying the current new directory.  This provides a
baseline for comparisons going forward.

The program then loops through all of the files in the new directory and copies
any that do not exist in the old directory.  Now both directories should be in
sync.

It is important to retain the $OLDDIR for as long as possible to reap the most
benefits from the AWS S3 ~sync~ command.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  NEWDIR=$1
  OLDDIR=$2

  [[ -d $NEWDIR ]] || { echo "ERROR: $NEWDIR does not exist"; exit 1; }
  [[ -d $OLDDIR ]] || { echo "CREATING: $OLDDIR does not exist"; cp -a $NEWDIR $OLDDIR; exit 0; }

  for oldfile in $OLDDIR/*
  do
      newfile=$NEWDIR/$(basename $oldfile)
      if [[ -e $newfile ]]
      then
	      if cmp -s $newfile $oldfile
	      then
	          printf "${GREEN}copying OLD to NEW${CLEAR}: "
	          cp -vp $oldfile $newfile
	      else
	          printf "${MAGENTA}copying NEW to OLD${CLEAR}: "
	          cp -vp $newfile $oldfile
	      fi
      else
	      printf "${RED}removing OLD:${CLEAR} "
	      rm -v $oldfile
      fi
  done

  for newfile in $NEWDIR/*
  do
      oldfile=$OLDDIR/$(basename $newfile)
      [[ -e $oldfile ]] || { printf "${BLUE}copying NEW to OLD${CLEAR}: "
			     cp -vp $newfile $oldfile; }
  done
#+end_src


* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:


* Footnotes

[fn:1]Org requires [[https://github.com/clojure-emacs/clojure-mode][Clojure-mode]] to work with clojure source code.  Clojure mode
provides Emacs font-lock, indentation, navigation and refactoring for the
Clojure(Script) programming language.


* Export Configurations                                            :noexport:
#+texinfo_filename:clojure.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Programming Languages
#+texinfo_dir_title:Clojure
#+texinfo_dir_desc:All about the elegant language of Clojure
#+texinfo_printed_title:All About Clojure


* Local Variables                                                  :noexport:
# Local Variables:
# fill-column: 79
# indent-tabs-mode: t
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (electric-quote-local-mode t)
# End:
