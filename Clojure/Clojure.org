# -*- mode:org; -*-

#+title:Clojure
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-01-29 23:48
#+macro:version Version 0.0.29

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying


* Introduction to Clojure
:PROPERTIES:
:unnumbered: t
:END:

“Clojure is a robust, practical, and fast programming language with a set of
useful features that together form a simple, coherent, and powerful tool.”

- [[https://clojure.org][Clojure Home]]

- [[https://clojure.org/reference/reader][Clojure Reference]]

- [[https://clojure.org/api/api][Clojure API]]

- [[https://clojure.org/guides/getting_started][Clojure Guides]]

- [[https://guide.clojure.style][The Clojure Style Guide]]

- [[https://github.com/clojure-emacs/clojure-mode][Clojure Mode]]


Clojure is a dynamic, general-purpose programming language, combining the
approachability and interactive development of a scripting language with an
efficient and robust infrastructure for multithreaded programming.  Clojure is
a compiled language, yet remains completely dynamic --- every feature supported
by Clojure is supported at runtime.  Clojure provides easy access to the Java
frameworks, with optional type hints and type inference, to ensure that calls
to Java can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data philosophy
and a powerful macro system.  Clojure is predominantly a functional programming
language, and features a rich set of immutable, persistent data structures.
When mutable state is needed, Clojure offers a software transactional memory
system and reactive Agent system that ensure clean, correct, multithreaded
designs.

** Clojure Features

#+texinfo:@heading Dynamic Development

Clojure is a dynamic environment you can interact with.  Almost all of the
language constructs are reified, and thus can be examined and changed.  You can
grow your program, with data loaded, adding features, fixing bugs, testing, in
an unbroken stream.

#+texinfo:@heading LISP

Clojure is a member of the Lisp family of languages.  Many of the features of
Lisp have made it into other languages, but Lisp's approach to code-as-data and
its macro system still set it apart.  Additionally, Clojure’s maps, sets, and
vectors are as first class in Clojure as lists are in Lisp.

#+texinfo:@heading Concurrent Programming

Clojure simplifies multi-threaded programming in several ways.  Because the
core data structures are immutable, they can be shared readily between threads.
Clojure, being a practical language, allows state to change but provides
mechanism to ensure that, when it does so, it remains consistent, while
alleviating developers from having to avoid conflicts manually using locks etc.

#+texinfo:@heading Functional Programming

Clojure provides the tools to avoid mutable state, provides functions as
first-class objects, and emphasizes recursive iteration instead of side-effect
based looping.  Clojure is impure, yet stands behind the philosophy that
programs that are more functional are more robust.

#+texinfo:@heading Runtime Polymorphism

Systems that utilize runtime polymorphism are easier to change and extend.
Clojure offers simple, powerful and flexible mechanisms for runtime
polymorphism.  Clojure’s protocols and datatypes features add mechanisms for
abstraction and data structure definition with no compromises vs the facilities
of the host platform.

#+texinfo:@heading Hosted on the JVM

Clojure is designed to be a hosted language, sharing the JVM type system, GC,
threads etc.  All functions are compiled to JVM bytecode.  Clojure is a great
Java library consumer, offering the dot-target-member notation for calls to
Java.  Clojure supports the dynamic implementation of Java interfaces and
classes.

** Clojure Style Guide
“A community coding style guide for the Clojure programming language.”

- https://guide.clojure.style

- https://github.com/bbatsov/clojure-style-guide

** Clojure Coding Guidelines

- https://clojure.org/community/contrib_howto#_coding_guidelines

** Resources

*** Clojure Programming

- http://www.clojurebook.com

- https://github.com/clojurebook/ClojureProgramming

* Clojure for the Brave and True
:PROPERTIES:
:url: https://www.braveclojure.com
:author:   "Daniel Higginbotham"
:author-blog: http://flyingmachinestudios.com
:reviewer-blog: http://tailrecursion.com/~alan
:copyright: 2015
:publisher: "No Starch Press"
:isbn:     1-59327-591-9
:isbn-13:  978-1-59327-591-4
:END:


[[https://www.braveclojure.com/clojure-for-the-brave-and-true/][Read the Online Version]]

[[https://github.com/braveclojure/cftbat-code/][All the Code for the book on GitHub]]

** Forward
:PROPERTIES:
:unnumbered: t
:END:
#+cindex:John McCarthy
#+cindex:Lisp
You will eventually learn through reading this book that programming is more
enjoyable after knowing some Clojure.  Clojure is the most elegant programming
language every designed.  Elegance is a quality regularly ascribed to many
dialects in the family of programming languages known collectively as Lisp, or
which Clojure is one.   All Lisps descend from a set of siimple and beautiful
discoveries made by the mathematician John McCarthy in 1958.

** Introduction
:PROPERTIES:
:unnumbered: t
:END:

*** Learning a New Programming Language---A Journey through the Four Labyrinths
To wield Clojure to its fullest, you’ll need to find your way through the four
labyrinths that face every programmer learning a new language:

#+attr_texinfo: :indic b
- The Forest of Tooling ::

     A friendly and efficient programming environment makes it easy to try your
     ideas.  You’ll learn how to set up your environment.

- The Mountain of Language ::

     As you ascend, you’ll gain knowledge of Clojure’s syntax, semantics, and
     data structures.  You’ll learn how to use one of the mightiest programming
     tools, the macro, and learn how to simplify your life with Clojure’s
     concurrency constraints.

- The Cave of Artifacts ::

     In its depths, you’ll learn to build, run, and distribute your own
     programs, and how to use code libraries.  You’ll also learn Clojure’s
     relationship to the Java Virtual Machine (JVM).

- The Cloud Castle of Mindset ::

     In its rarefied air, you’ll come to know they why and how of Lisp and
     functional programming.  You’ll learn about the philosophy of simplicity
     that permeates Clojure, and how to solve problems like a Clojurist.


This book follows three guidelines:

1. It takes the dessert-first approach, giving you the development tools and
   language details you need to start playing with real programs immediately.

2. It assumes zero experience with the JVM, functional programming, or Lisp.
   It covers these topics in detail so you’ll feel confident about what you’re
   doing when you build and run Clojure programs.

3. It eschews /real-world/ examples in favor of more interesting exercises,
   like /assaulting hobbits/ and /tracking glittery vampires/.


By the end, you’ll be able to use Clojure.

*** How this Book is Organized

This book is split into three parts to better guide you through your valient
quest, brave fledgling Clojurist.

#+texinfo:@heading Part I---Environment Setup

Theswe chapters take you on a quick tour of the tools you’ll need to easily
write programs.

#+texinfo:@subheading Chapter 1---Building-Running-and the REPL

There’s something powerful and motivating about getting a real program
running.  Once you can do that, you’re free to experiment, and you can actually
share your work!

In this chapter, you’ll invest a small amount of time to become familiar with a
quick way to build and run Clojure programs.  You’ll learn how to experiment
with code in a running Clojure process using a read-eval-print loop (REPL).
This will tighten your feedback loop and help you learn more efficiently.

#+texinfo:@subheading How to use Emacs---an excellent Clojure Editor

A quick feedback loop is crucial for learning.  In this chapter, I cover Emacs
from the ground up to guarantee you have an efficient Emacs/Clojure workflow.

#+texinfo:@heading Part II---Language Fundamentals

These chapters give you a solid foundation on which to continue learning
Clojure.  You’ll start by learning Clojure’s basics (syntax, semantics, and
data structures) so you can /do things/.  Then you’ll take a step back to
examine Clojure’s most used functions in detail and learn how to solve problems
with them using the /functional programming/ mindset.

#+texinfo:@subheading Chapter 3---Do Things---a Clojure Crash Course

Clojure’s most salient characteristic is that it is a Lisp.  You’ll explore
this Lisp core, which is composed of two parts: functions and data.

#+texinfo:@subheading Chapter 4---Core Functions in Depth

In this chapter you’ll learn about a couple of Clojure’s underlying concepts.
This will give you the grounding you need to read the documentation for
functions you haven’t used before and to understand what’s happening when you
try them.

You’ll also see usage examples of the functions you’ll be reading for the
most.  This will give you a solid foundation for writing your own code and for
reading and learning from other people’s projects.

#+texinfo:@subheading Chapter 5---Functional Programming

In this chapter, you’ll take your concrete experience with functions and data
structures and integrate it with a new mindset: the functional programming
mindset.

#+texinfo:@subheading Chapter 6---Organizing your Project---A Librarian’s Tale

This chapter explains what namespaces are and how to use them to organize your
code.

#+texinfo:@subheading Chapter 7---Clojure Alchemy---Reading, Evaluation, and Macros

In this chapter, you’ll take a step back and describe how Clojure runs your
code.  This will give you the conceptual structure you need to truly understand
how Clojure works and how it’s different from other, non-Lisp languages.  With
this structure in place, I’ll introduce the macro, one of the most powerful
tools in existence.

#+texinfo:@subheading Writing Macros

This chapter thoroughly examines how to write macros, starting with basic
examples and advancing in complexity.

#+texinfo:@heading Part III---Advanced Topics

These chapters cover Clojure’s extra-fun topics---concurrency, Java interop and
abstraction.  Although you can write programs without understanding these tools
and concepts, they’re intellectually rewarding and give you tremendous power as
a programmer.  One of the reasons people say that learning Clojure makes you a
better programmer is that it makes the concepts covered in these chapters easy
to understand and practical to use.

#+texinfo:@subheading Chapter 9---The Sacred Art of Concurrent and Parallel Programming

In this chapter you’ll learn what concurrency and parallelism are and why they
matter.  You’ll learn about challenges you’ll face when writing parallel
programs and about how clojure’s design helps to mitigate them.  You’ll use
futures, delays, and promises to safely write parallel programs.

#+texinfo:@subheading Chapter 10---Clojure Metaphysics---Atoms, Refs, Vars, and Cuddle Zombies

This chapter goes into great detail about Clojure’s approach to managing state
and how that simplifies concurrent programmibng.  You’ll learn how to use
atoms, refs, and vars, three constructs for managing state, and you’ll learn
how to do stateless parallel computation with ~pmap~.  And there will be cuddle
zombies.

#+texinfo:@subheading Chapter 11---Mastering Concurrent Processes with ~core.async~

In this chapter, you’ll ponder the idea that everything in the univese is a hot
dog vending machine.  By which I mean you’ll learn how to model systems of
independently running processes that communicate with each other over channels
using the ~core.async~ library.

#+texinfo:@subheading Chapter 12---Working with the JVM

This chapter is like a phrase book and cultural introduction to the Land of
Java.  It gives you an overview of what the JVM is, how it runs programs, and
how to compile programs for it.  It also gives you a brief tour of frequently
used Java classes and methods, and explains how to interact with them from
Clojure.  It shows you how to think about and understand Java so you can
incorporate any Java library into your Clojure program.

#+texinfo:@subheading Chapter 13---Creating and Extending Abstractions with Multimethods, Protocols, and Records

This chapter serves as an introduction to the world of cereating and
implementing your own abstractions.  You’ll learn the basics of multimethods,
protocols, and records.

#+texinfo:@heading Appendix A---Building and Developing with Leiningen

This appendix clarifies some of the finer points of working with Leiningen,
like what Maven is and how to figure out the version numbers of Java libraries
so you can use them.

#+texinfo:@heading Appendix B---Boot, the Fancy Clojure Build Framework

Boot is an alternative to Leiningen that provides the same functionality, but
with the added bonus that its easier to extend and write composable tasks.
This appendix explains Boot’s underlying concepts and guides you through
writing your first tasks.

*** The Code

You can download all the source code from the book at
https://github.com/braveclojure/cftbat-code/.  The code is organized by
chapter.

Chapter 1 describes the different ways tht you can run Clojure code, including
how to use a REPL.  I recommend running most of the examples in the REPL as you
encounter them.  This will help you get used to writing and understanding Lisp
code, and it will help you retain everything you’re learning.  But for the
examples that are long, it’s best to write the code to a file, and then run the
code you wrote in a REPL.

*** The Journey Begins!

** Building---Running---and the REPL
:PROPERTIES:
:chapter:  1
:part:     I
:END:

In this chapter, you’ll invest a small amount of time up front to get familiar
with a quick, foolproof way to build and run Clojure programs.  It feels great
to get a real program running.  Reaching that milestone frees you up to
experiment, share your work, and gloat.

You’ll also learn how to instantly run code within a running Clojure process
using a /Read-Eval-Print Loop (REPL)/, which allows you to quickly test your
understanding of the language and learn more efficiently.

First, I’ll introduce you to Clojure.

Next, I’ll cover Leiningen, the de facto standard build tool for Clojure.

By the end of the chapter, you’ll know how to do the following:

- Create a new Clojure project with Leiningen

- Build the project to create an executable JAR file

- Execute the JAR file

- Execute code in a Clojure REPL

*** What is Clojure

When talking about Clojure, it’s important to keep in mind the distinction
between the Clojure language and the Clojure compiler.  The Clojure language is
a Lisp dialect with a functional emphasis whose syntax and semantics are
independent of any implementation.   The compiler is an executable JAR file,
~clojure.jar~, which takes code written in the Clojure language and compiles it
to a Java Virtual Machine (JVM) bytecode.

This distinction is necessary because, unlike most programming languages like
Ruby, Python, C, and others, Clojure is a /hosted language/.  Clojure programs
are executed within a JVM and rely on the JVM for core features like threading
and garbage collection.  Clojure also targets JavaScript and the Microsoft
Common Language runtime (CLR), but this book only focuses on the JVM
implementation.

For now the main concepts you need to understand are these:

#+cindex:@code{clojure.jar}
- JVM processes execute Java bytecode

- Usually, the Java Compiler produces Java bytecode from Java source code

- JAR files are collections of Java bytecode

- Java programs are usually distributed as JAR files

- The Java program ~clojure.jar~ reads Clojure source code and produces Java
  bytecode

- That Java bytecode is then executed by the same JVM process already running
  ~clojure.jar~

*** Leiningen                                                :dependencies:
:PROPERTIES:
:dependency1: shell
:dependency2: bash
:dependency3: java
:dependency4: clojure
:END:

This code checks for installed dependencies.  If something is not installed,
then the code in this Org project will not work properly.  Make sure you have
Java version 1.6 or later installed, and Bash version 4 or later installed.
Also make sure your Org setup can work with the programming languages 'shell
and 'clojure, in addition to 'elisp.  These should be added to
'org-babel-load-languages if they are not.

#+name:check-language-depencencies
#+header: :results output :exports results
#+begin_src elisp
  (princ "This will now check the Org variable \'org-babel-load-languages to make sure it includes 
  \'shell and \'clojure.\n\n")
  (if
      (assoc 'shell org-babel-load-languages)
      (princ "\'shell enabled\n")
    (princ "\'shell not enabled\n"))
  (if
      (assoc 'clojure org-babel-load-languages)
      (princ "\'clojure enabled")
    (princ "\'clojure not enabled"))
#+end_src

#+RESULTS: check-language-depencencies
: shell enabled
: clojure enabled

#+name:check-java-bash-dependencies
#+header: :results output :exports results
#+begin_src sh
echo "This will now check whether Java and Bash are installed on your system."
echo
echo Java:
java -version 2>&1
echo
echo Bash:
bash --version
#+end_src

#+RESULTS: check-java-bash-dependencies
: GNU bash, version 5.0.11(1)-release (x86_64-apple-darwin18.7.0)
: Copyright (C) 2019 Free Software Foundation, Inc.
: License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
: 
: This is free software; you are free to change and redistribute it.
: There is NO WARRANTY, to the extent permitted by law.

#+cindex:Leiningen
Most Clojurists use Leiningen to build and manage their projects.  For now
we’ll focus on using it for four tasks:

1. Creating a new Clojure project

2. Running the Clojure project

3. Building the Clojure project

4. Using the REPL


#+cindex:@code{clojure.jar}
[[*Leiningen Installation Instructions][Install Leiningen]] using the instructions on the Leiningen home page at
http://leiningen.org.  When you install Leiningen, it automatically downloads
the Clojure compiler, ~clojure.jar~.

**** Creating a New Clojure Project                         :dependencies:
:PROPERTIES:
:dependency5: tree
:END:

#+pindex:project, create new
Creating a new Clojure project is very simple.  A single Leiningen command
creates a project skeleton.  Later, you’ll learn how to do tasks like
incorporate Clojure libraries.

#+cindex:@command{lein}
Create your first Clojure project by typing the following in your terminal:

: lein new app clojure-noob

#+name:new-clojure-project
#+header: :results output :exports results
#+begin_src sh
  if [[ ! -d projects ]]
  then
      mkdir -p projects/
      cd projects
      lein new app clojure-noob
  else
      cd projects
  fi

  [[ $(tree --version) ]] && \
	tree clojure-noob || {
	   echo "Install the 'tree' command to see the project skeleton."
	   echo http://mama.indstate.edu/users/ice/tree
	}

#+end_src

#+cindex:project skeleton
This project skeleton isn’t special or required by Clojure.  It is a convention
used by Leiningen.  You will be using Leiningen to build and run Clojure apps,
and Leiningen expects your app to have this structure.

#+cindex:@file{project.clj}
- ~project.clj~ is a configuration file for Leiningen.  It helps Leiningen
  answer such questions as “What dependencies does this project have?” and
  “When this Clojure program runs, what function should run first?”

- In general, you’ll save your source code in ~src/<project_name>/~.  This this
  case, the file ~src/clojure_noob/core.clj~ is where you will be writing  your
  Clojure code for a while.

- The ~test/~ directory containts tests;

- The ~resources/~ directory is where you store assets like immages.

**** Running the Clojure Project

Open the source file ~src/clojure_noob/core.clj~ in an editor.  It should look
like this:

#+pindex:clojure_nobe/core.clj
#+caption: clojure-noob.core.clj File
#+name:initial-clojure_noob-core.clj
#+header: :results output verbatim
#+header: :exports results
#+header: :dir projects/clojure-noob/src/clojure_noob
#+begin_src sh
cat -n core.clj
#+end_src

#+RESULTS: initial-clojure_noob-core.clj
:      1	(ns clojure-noob.core
:      2	  (:gen-class))
:      3	
:      4	(defn -main
:      5	  "I don't do a whole lot ... yet."
:      6	  [& args]
:      7	  (println "Hello, World!"))

#+cindex:namespace
The code ~(ns ...)~ declares a /namespace/.  Do not worry about namespaces for
the moment.

#+cindex:entry point
#+cindex:@code{-main} function
The ~-main~ function is the /entry point/ to your program.

#+cindex:@code{lein run}
To run the program, navigate to the ~clojure_noob/~ directory and enter the
following command:

#+caption: Run a Project from the Command Line
#+name:run-project-clojure-noob
#+header: :dir projects/clojure-noob/src/clojure_noob
#+header: :results output :exports both
#+begin_src sh
lein run
#+end_src

#+RESULTS: run-project-clojure-noob
: Hello, World!

If you see “Hello, World!” output, then your Clojure project ran successfully.
You created a function ~-main~, and it runs when you execute ~lein run~ at the
command line.

**** Building the Clojure Project
#+cindex:jar file, create
You can create a stand-alone file that anyone with Java installed can execute.
To create the file, run this:

#+cindex:@command{lein uberjar}
#+caption:Create a jar File
#+name:create-first-jar-file
#+header: :dir projects/clojure-noob
#+header: :results output :exports both
#+begin_src sh
lein uberjar
#+end_src

#+RESULTS: create-first-jar-file
: Created /Users/pine/Dev/Languages/Clojure/Clojure/projects/clojure-noob/target/uberjar/clojure-noob-0.1.0-SNAPSHOT.jar
: Created /Users/pine/Dev/Languages/Clojure/Clojure/projects/clojure-noob/target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar

This command creates the file:

: ./target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar

You can make Java execute it by running this:

#+caption:Run a jar File
#+name:run-first-jar-file
#+header: :dir projects/clojure-noob
#+header: :results output :exports both
#+begin_src sh
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
#+end_src

#+RESULTS: run-first-jar-file
: Hello, World!

Again, if you see the output “Hello, World!” then Java has successfully run
your project from the ~.jar~ file.  You can distribute and run this program on
virtually every platform.

You now have all the basic details you need to build, run, and distribute
(very) basic Clojure programs.  In later chapters, you’ll learn more details
about what Leiningen is doing when you run the preceding commands, and gaining
a complete understanding of Clojure’s relationship to the JVM and how you cna
run production code.

**** Using the REPL
#+cindex:REPL
The REPL is a tool for experimenting with code.  It allows you to interact with
a running program and quickly try out ideas.  It does this by presenting you
with a prompt where you can enter code.  It then /reads/ your input,
/evaluates/ it, /prints/ the result, and /loops/, presenting you with a prompt
again.

This process enables a quick feedback cycle that isn’t possible in most other
languages.  REPL development is an essential part of the Lisp experience.

#+texinfo:@heading Start a REPL

From within the ~projects/clojure-noob/src/clojure_noob/~ directory, type:

: lein repl

The output should look like:

#+begin_example
nREPL server started on port 55877 on host 127.0.0.1 - nrepl://127.0.0.1:55877
REPL-y 0.4.3, nREPL 0.6.0
Clojure 1.10.0
OpenJDK 64-Bit Server VM 1.8.0_232-b09
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

clojure-noob.core=>
#+end_example

#+cindex:namespace
The last line, ~clojore-noob.core~, tells you that you are in the
~clojure-noob.core~ namespace.  The prompt also indicates that your code is
loaded in the REPL, and you can execute the functions that are defined.  Right
now only one function, ~-main~, is defined.  Execute it now:

#+begin_example
clojure-noob.core=> (-main)
Hello, World!
nil
clojure-noob.core=>
#+end_example

#+texinfo:@heading Secure Shell (SSH)

Conceptually, the REPL is similar to Secure Shell (SSH).  In the same way that
you can use SSH to interact with a remote server, the Clojure REPL allows you
to interact with a running Clojure process.  This feature can be very powerful
because you can even attach a REPl to a live production app and modify your
program as it runs.
*** Clojure Editors

#+cindex:Emacs
If you wanty a good tutorial on a powerful editor, Chapter 2 covers Emacs, the
most popular editor amount Clojurists.  Emacs offers tighty integration with
the Clojure REPL and is well-suited to writing Lisp code.

*** Summary
You’ve run your first Clojure program.  You’ve become acquainted with the REPL,
one of the most important tools for developing Clojure software.

** How to use Emacs

#+cindex:Emacs
It is worthwhile to invest some time in setting up your editor to work with a
REPL.  The reason the author recommends Emacs is that it offers tight
integration with a Clojure REPL, which allows you to instantly try out your
code as you write.  Emacs is also great for working with any Lisp dialect.

*** Emacs Installation
#+cindex:Emacs installation
You should use the latest major version of Emacs for the platform you are
working on.

- OS X :: Install vanilla Emacs as a Mac app from http://emacsformacosx.com/

- Ubuntu :: Follow the instructions at
            https://launchpad.net/~ubuntu-elisp/+archive/ppa[fn:3]

- Windows :: You can find a binary at http://ftp.gnu.org/gnu/emacs/windows.


After installing, open Emacs.

*** Emacs Configuration

- [[https://github.com/flyingmachine/emacs-for-clojure][flyingmachine / emacs-for-clojure]]

#+cindex:configuring Emacs
The author has made a repository of all the files you need to configure Emacs
for Clojure, available in the book’s resources at as a =zip= download:

- https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip

*NOTE:* These tools are constantly being updated, so if the instructions below
don't work for you or you want to use the latest configuration, please read the
instructions at the link given above.

*** CFBT Initialization Setup
:PROPERTIES:
:header-args: :mkdirp yes
:END:

These files and directories will replace the current Emacs configuration.  One
option is to delete the current configuration and install these in their place.
That is the option chosen by the author.  Another option is to save the current
configuration and install these temporarily, and then provide a way to switch
between them.  A third option is to merge the current configuration with this
configuration instead of completely deleting it.

For the time being, I will use the second option: keep both and provide a means
of switching between them.  Later I will work on merging desired configurations
together.  These files will go into a directory ~/.emacs.d-cfbt/~.  The current
~/.emacs.d~ will be moved into ~/.emacs.d-original~.  A sym-link on ~/.emacs.d~
will be set up to use either ~/.emacs.d-original~ or ~/.emacs-d-cfbt~.  Emacs
should be restarted when a switch is made.

#+findex:desktop-save
I have created a shell script to facilitate switching between different emacs
initialization setups: ~switch-emacs-init~.  It is run from the command line,
and so is put into a ~bin/~ directory located through the =$PATH= variable.
After a switch, Emacs must be restarted.  Killing Emacs from the command-line
is probably not the best solution, but it is manageable using the
~desktop~save~ feature of Emacs.

#+texinfo:@heading Custom Init.el for Clojure for the Brave and True

#+name:cfbt-init.el
#+header: :noweb yes
#+header: :tangle ~/.emacs.d-cfbt/init.el
#+begin_src emacs-lisp -n
<<cfbt-packages>>
<<cfbt-my-packages>>
<<cfbt-load-packages>>
<<cfbt-customization>>
<<cfbt-custom-set-vars-and-faces>>
#+end_src

#+texinfo:@heading Custom .gitignore for Clojure for the Brave and True

#+name:.gitignore
#+header: :tangle ~/.emacs.d-cfbt/.gitignore
#+begin_src shell
.smex-items
*~$
places
.recentf
ido.last
cider-history
projectile-bookmarks.eld
projectile.cache
auto-save-list
backups
melpa-stable
archive-contents
*.elc
#+end_src

#+texinfo:@heading Add an ELPA Directory

This code creates ~elpa/~ and ~themes/~ directories.  Themes will be downloaded
from the source repository, but files in the Elpa directory will be
auto-generated.  While these themes are fairly old, they probably work just
fine.

I could not find a simple solution to download all files from a single
directory from a GitHub repo, so resorted to a combination of ~curl~, the
GitHub REST API =GET /repos/<USER>/<REPO>/contents/<DIR>= command and an ~awk~
script.

The =GET= API command produces information in the form of a JSON object about
the directory, including a =download_url= for each file in the directory, which
can be used to download each file in the directory one-by-one.  The script uses
~awk~ to process the information so that ~curl~ can do its work for each file.

The ~awk~ script is triggered for each such =download_url= line.  The url found
in =$2= is cleaned of quote characters and commas using ~gsub()~.  Then a
~system~ command is made that uses ~curl~ to download the file using the
=download_url= found in =$2=.  This script seems to be fairly fast in practice.

#+name:cfbt-elpa-themes
#+header: :results output :exports both
#+header: :eval yes
#+begin_src sh
mkdir -vp ~/.emacs.d-cfbt/elpa
mkdir -vp ~/.emacs.d-cfbt/themes
cd ~/.emacs.d-cfbt/themes
curl -sH "Authorization: token $GITHUB_TOKEN" \
  https://api.github.com/repos/flyingmachine/emacs-for-clojure/contents/themes | awk \
  '/download_url/ {
      gsub("\"|,","",$2);
      system("curl -O "$2);
   }'
#+end_src

**** Package Setup                                              :noexport:

#+name:cfbt-packages
#+begin_src emacs-lisp
;;;;
;; Packages
;;;;

;; Define package repositories
(require 'package)
(add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t)
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))

#+end_src

**** Custom List of Packages                                    :noexport:

The packages you want installed. You can also install these manually with =M-x
package-install=; add in your own as you wish:

#+name:cfbt-my-packages
#+begin_src emacs-lisp
  (defvar my-packages
    '(;; makes handling lisp expressions much, much easier
      ;; Cheatsheet: http://www.emacswiki.org/emacs/PareditCheatsheet
      paredit

      ;; key bindings and code colorization for Clojure
      ;; https://github.com/clojure-emacs/clojure-mode
      clojure-mode

      ;; extra syntax highlighting for clojure
      clojure-mode-extra-font-locking

      ;; integration with a Clojure REPL
      ;; https://github.com/clojure-emacs/cider
      cider

      ;; allow ido usage in as many contexts as possible. see
      ;; customizations/navigation.el line 23 for a description
      ;; of ido
      ido-completing-read+

      ;; Enhances M-x to allow easier execution of commands. Provides
      ;; a filterable list of possible commands in the minibuffer
      ;; http://www.emacswiki.org/emacs/Smex
      smex

      ;; project navigation
      projectile

      ;; colorful parenthesis matching
      rainbow-delimiters

      ;; edit html tags like sexps
      tagedit

      ;; git integration
      magit))

  (when (eq system-type 'darwin)
      ;; https://github.com/purcell/exec-path-from-shell A GNU Emacs
      ;; library to ensure environment variables inside Emacs look the
      ;; same as in the user's shell.
      (add-to-list 'my-packages 'exec-path-from-shell))

  (dolist (p my-packages)
    (when (not (package-installed-p p))
      (package-install p)))

  ;; Place downloaded elisp files in ~/.emacs.d/vendor. You'll then be able
  ;; to load them.
  ;;
  ;; For example, if you download yaml-mode.el to ~/.emacs.d/vendor,
  ;; then you can add the following code to this file:
  ;;
  ;; (require 'yaml-mode)
  ;; (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  ;; 
  ;; Adding this code will make Emacs enter yaml mode whenever you open
  ;; a .yml file
  (add-to-list 'load-path "~/.emacs.d/vendor")
#+end_src

**** Customization                                              :noexport:

#+name:cfbt-customization
#+begin_src emacs-lisp
  ;;;;
  ;; Customization
  ;;;;

  ;; Add a directory to our load path so that when you `load` things
  ;; below, Emacs knows where to look for the corresponding file.
  (add-to-list 'load-path "~/.emacs.d/customizations")

  ;; Sets up exec-path-from-shell so that Emacs will use the correct
  ;; environment variables
  (load "shell-integration.el")

  ;; These customizations make it easier for you to navigate files,
  ;; switch buffers, and choose options from the minibuffer.
  (load "navigation.el")

  ;; These customizations change the way emacs looks and disable/enable
  ;; some user interface elements
  (load "ui.el")

  ;; These customizations make editing a bit nicer.
  (load "editing.el")

  ;; Hard-to-categorize customizations
  (load "misc.el")

  ;; For editing lisps
  (load "elisp-editing.el")

  ;; Langauage-specific
  (load "setup-clojure.el")
  (load "setup-js.el")
#+end_src

**** Custom Variables and Faces                                 :noexport:
#+name:cfbt-custom-vars-and-faces
#+begin_src emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(coffee-tab-width 2)
   '(package-selected-packages
     (quote
      (magit tagedit rainbow-delimiters projectile smex ido-completing-read+ cider clojure-mode-extra-font-locking clojure-mode paredit exec-path-from-shell))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
#+end_src

*** CFBT Customizations
:PROPERTIES:
:header-args: :mkdirp yes
:END:

**** editing

#+name:cfbt-editing.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/editing.el
#+begin_src emacs-lisp -n
  ;; Customizations relating to editing a buffer.

  ;; Magit-mode global key bindings
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)

  ;; Org-mode global key bindings
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-switchb)

  ;; Key binding to use "hippie expand" for text autocompletion
  ;; http://www.emacswiki.org/emacs/HippieExpand
  (global-set-key (kbd "M-/") 'hippie-expand)

  ;; Lisp-friendly hippie expand
  (setq hippie-expand-try-functions-list
	'(try-expand-dabbrev
	  try-expand-dabbrev-all-buffers
	  try-expand-dabbrev-from-kill
	  try-complete-lisp-symbol-partially
	  try-complete-lisp-symbol))

  ;; Highlights matching parenthesis
  (show-paren-mode 1)

  ;; Highlight current line
  (global-hl-line-mode 1)

  ;; Interactive search key bindings. By default, C-s runs
  ;; isearch-forward, so this swaps the bindings.
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)

  ;; Don't use hard tabs
  (setq-default indent-tabs-mode nil)

  ;; When you visit a file, point goes to the last place where it
  ;; was when you previously visited the same file.
  ;; http://www.emacswiki.org/emacs/SavePlace
  (require 'saveplace)
  (setq-default save-place t)
  ;; keep track of saved places in ~/.emacs.d/places
  (setq save-place-file (concat user-emacs-directory "places"))

  ;; Emacs can automatically create backup files. This tells Emacs to
  ;; put all backups in ~/.emacs.d/backups. More info:
  ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
						 "backups"))))
  (setq auto-save-default nil)


  ;; comments
  (defun toggle-comment-on-line ()
    "comment or uncomment current line"
    (interactive)
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
  (global-set-key (kbd "C-;") 'toggle-comment-on-line)

  ;; use 2 spaces for tabs
  (defun die-tabs ()
    (interactive)
    (set-variable 'tab-width 2)
    (mark-whole-buffer)
    (untabify (region-beginning) (region-end))
    (keyboard-quit))

  ;; fix weird os x kill error
  (defun ns-get-pasteboard ()
    "Returns the value of the pasteboard, or nil for unsupported formats."
    (condition-case nil
	(ns-get-selection-internal 'CLIPBOARD)
      (quit nil)))

  (setq electric-indent-mode nil)
  (electric-pair-mode)
#+end_src

**** elisp-editing

#+name:cfbt-elisp-editing.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/elisp-editing.el
#+begin_src emacs-lisp -n
  ;; Customizations relating to editing a buffer.

  ;; Key binding to use "hippie expand" for text autocompletion
  ;; http://www.emacswiki.org/emacs/HippieExpand
  (global-set-key (kbd "M-/") 'hippie-expand)

  ;; Lisp-friendly hippie expand
  (setq hippie-expand-try-functions-list
	'(try-expand-dabbrev
	  try-expand-dabbrev-all-buffers
	  try-expand-dabbrev-from-kill
	  try-complete-lisp-symbol-partially
	  try-complete-lisp-symbol))

  ;; Highlights matching parenthesis
  (show-paren-mode 1)

  ;; Highlight current line
  (global-hl-line-mode 1)

  ;; Interactive search key bindings. By default, C-s runs
  ;; isearch-forward, so this swaps the bindings.
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)

  ;; Don't use hard tabs
  (setq-default indent-tabs-mode nil)

  ;; When you visit a file, point goes to the last place where it
  ;; was when you previously visited the same file.
  ;; http://www.emacswiki.org/emacs/SavePlace
  (require 'saveplace)
  (setq-default save-place t)
  ;; keep track of saved places in ~/.emacs.d/places
  (setq save-place-file (concat user-emacs-directory "places"))

  ;; Emacs can automatically create backup files. This tells Emacs to
  ;; put all backups in ~/.emacs.d/backups. More info:
  ;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
						 "backups"))))
  (setq auto-save-default nil)


  ;; comments
  (defun toggle-comment-on-line ()
    "comment or uncomment current line"
    (interactive)
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
  (global-set-key (kbd "C-;") 'toggle-comment-on-line)

  ;; use 2 spaces for tabs
  (defun die-tabs ()
    (interactive)
    (set-variable 'tab-width 2)
    (mark-whole-buffer)
    (untabify (region-beginning) (region-end))
    (keyboard-quit))

  ;; fix weird os x kill error
  (defun ns-get-pasteboard ()
    "Returns the value of the pasteboard, or nil for unsupported formats."
    (condition-case nil
	(ns-get-selection-internal 'CLIPBOARD)
      (quit nil)))

  (setq electric-indent-mode nil)
#+end_src

**** misc

#+name:cfbt-misc.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/misc.el
#+begin_src emacs-lisp -n
  ;; Automatically load paredit when editing a lisp file
  ;; More at http://www.emacswiki.org/emacs/ParEdit
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)

  ;; eldoc-mode shows documentation in the minibuffer when writing code
  ;; http://www.emacswiki.org/emacs/ElDoc
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+end_src

**** navigation

#+name:cfbt-navigation.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/navigation.el
#+begin_src emacs-lisp -n
;; Changes all yes/no questions to y/n type
(fset 'yes-or-no-p 'y-or-n-p)

;; shell scripts
(setq-default sh-basic-offset 2)
(setq-default sh-indentation 2)

;; No need for ~ files when editing
(setq create-lockfiles nil)

;; Go straight to scratch buffer on startup
(setq inhibit-startup-message t)
#+end_src

**** setup-clojure

#+name:cfbt-setup-clojure.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/setup-clojure.el
#+begin_src emacs-lisp -n
  ;;;;
  ;; Clojure
  ;;;;

  ;; Enable paredit for Clojure
  (add-hook 'clojure-mode-hook 'enable-paredit-mode)

  ;; This is useful for working with camel-case tokens, like names of
  ;; Java classes (e.g. JavaClassName)
  (add-hook 'clojure-mode-hook 'subword-mode)

  ;; A little more syntax highlighting
  (require 'clojure-mode-extra-font-locking)

  ;; syntax hilighting for midje
  (add-hook 'clojure-mode-hook
	    (lambda ()
	      (setq inferior-lisp-program "lein repl")
	      (font-lock-add-keywords
	       nil
	       '(("(\\(facts?\\)"
		  (1 font-lock-keyword-face))
		 ("(\\(background?\\)"
		  (1 font-lock-keyword-face))))
	      (define-clojure-indent (fact 1))
	      (define-clojure-indent (facts 1))
	      (rainbow-delimiters-mode)))

  ;;;;
  ;; Cider
  ;;;;

  ;; provides minibuffer documentation for the code you're typing into the repl
  (add-hook 'cider-mode-hook 'eldoc-mode)

  ;; go right to the REPL buffer when it's finished connecting
  (setq cider-repl-pop-to-buffer-on-connect t)

  ;; When there's a cider error, show its buffer and switch to it
  (setq cider-show-error-buffer t)
  (setq cider-auto-select-error-buffer t)

  ;; Where to store the cider history.
  (setq cider-repl-history-file "~/.emacs.d/cider-history")

  ;; Wrap when navigating history.
  (setq cider-repl-wrap-history t)

  ;; enable paredit in your REPL
  (add-hook 'cider-repl-mode-hook 'paredit-mode)

  ;; Use clojure mode for other extensions
  (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))


  ;; key bindings
  ;; these help me out with the way I usually develop web apps
  (defun cider-start-http-server ()
    (interactive)
    (cider-load-current-buffer)
    (let ((ns (cider-current-ns)))
      (cider-repl-set-ns ns)
      (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
      (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))


  (defun cider-refresh ()
    (interactive)
    (cider-interactive-eval (format "(user/reset)")))

  (defun cider-user-ns ()
    (interactive)
    (cider-repl-set-ns "user"))

  (eval-after-load 'cider
    '(progn
       (define-key clojure-mode-map (kbd "C-c C-v") 'cider-start-http-server)
       (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
       (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
       (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns)))
#+end_src

**** setup-js

#+name:cfbt-setup-js.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/setup-js.el
#+begin_src emacs-lisp -n
  ;; javascript / html
  (add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
  (add-hook 'js-mode-hook 'subword-mode)
  (add-hook 'html-mode-hook 'subword-mode)
  (setq js-indent-level 2)
  (eval-after-load "sgml-mode"
    '(progn
       (require 'tagedit)
       (tagedit-add-paredit-like-keybindings)
       (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))


  ;; coffeescript
  (add-to-list 'auto-mode-alist '("\\.coffee.erb$" . coffee-mode))
  (add-hook 'coffee-mode-hook 'subword-mode)
  (add-hook 'coffee-mode-hook 'highlight-indentation-current-column-mode)
  (add-hook 'coffee-mode-hook
	    (defun coffee-mode-newline-and-indent ()
	      (define-key coffee-mode-map "\C-j" 'coffee-newline-and-indent)
	      (setq coffee-cleanup-whitespace nil)))
  (custom-set-variables
   '(coffee-tab-width 2))
#+end_src

**** shell-integration

#+name:cfbt-shell-integration.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/shell-integration.el
#+begin_src emacs-lisp -n
  ;; Sets up exec-path-from shell
  ;; https://github.com/purcell/exec-path-from-shell
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-envs
     '("PATH")))
#+end_src

**** ui

#+name:cfbt-ui.el
#+header: :tangle ~/.emacs.d-cfbt/customizations/ui.el
#+begin_src emacs-lisp -n
  ;; These customizations change the way emacs looks and disable/enable
  ;; some user interface elements. Some useful customizations are
  ;; commented out, and begin with the line "CUSTOMIZE". These are more
  ;; a matter of preference and may require some fiddling to match your
  ;; preferences

  ;; Turn off the menu bar at the top of each frame because it's distracting
  (menu-bar-mode -1)

  ;; Show line numbers
  (global-linum-mode)

  ;; You can uncomment this to remove the graphical toolbar at the top. After
  ;; awhile, you won't need the toolbar.
  ;; (when (fboundp 'tool-bar-mode)
  ;;   (tool-bar-mode -1))

  ;; Don't show native OS scroll bars for buffers because they're redundant
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))

  ;; Color Themes
  ;; Read http://batsov.com/articles/2012/02/19/color-theming-in-emacs-reloaded/
  ;; for a great explanation of emacs color themes.
  ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Custom-Themes.html
  ;; for a more technical explanation.
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
  (add-to-list 'load-path "~/.emacs.d/themes")
  (load-theme 'tomorrow-night-bright t)

  ;; increase font size for better readability
  (set-face-attribute 'default nil :height 140)

  ;; Uncomment the lines below by removing semicolons and play with the
  ;; values in order to set the width (in characters wide) and height
  ;; (in lines high) Emacs will have whenever you start it
  (setq initial-frame-alist '((top . 10) (left . 10) (width . 200) (height . 53)))

  ;; These settings relate to how emacs interacts with your operating system
  (setq ;; makes killing/yanking interact with the clipboard
	x-select-enable-clipboard t

	;; I'm actually not sure what this does but it's recommended?
	x-select-enable-primary t

	;; Save clipboard strings into kill ring before replacing them.
	;; When one selects something in another program to paste it into Emacs,
	;; but kills something in Emacs before actually pasting it,
	;; this selection is gone unless this variable is non-nil
	save-interprogram-paste-before-kill t

	;; Shows all options when running apropos. For more info,
	;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Apropos.html
	apropos-do-all t

	;; Mouse yank commands yank at point instead of at click.
	mouse-yank-at-point t)

  ;; No cursor blinking, it's distracting
  (blink-cursor-mode 0)

  ;; full path in title bar
  (setq-default frame-title-format "%b (%f)")

  ;; don't pop up font menu
  (global-set-key (kbd "s-t") '(lambda () (interactive)))

  ;; no bell
  (setq ring-bell-function 'ignore)
#+end_src

** Clojure Crash Course
** Core Functions in Depth
** Functional Programming
** Organizing Your Project
** Reading Evaluation and Macros
** Writing Macros
** Concurrent and Parallel Programming
** Atoms---Refs---Vars---Cuddle Zombies
** Mastering Concurrent Processes with core.async
** Working with the JVM
** Creating and Extending Abstractions with Multimethods-Protocols-and Records
** Building and Developing with Leiningen
** Boot---Clojure Build Framework
** Farewell

* About Leiningen

“(Leiningen is) for automating Clojure projects without setting your hair on
fire.”

Leiningen is the easiest way to use Clojure.  With a focus on /project
automation/ and /declarative configuration/, it gets out of your way and lets
you focus on your code.

- [[https://leiningen.org][Leiningen Home]]

- [[https://github.com/technomancy/leiningen][Leiningen on GitHub]]


#+cindex:Leiningen, version
Installed version of Leining on this computer:

#+begin_comment
The following code does not produce an output when this file is exported to
texinfo from the Makefile, but it does when exported from the export
dispatcher.  No idea why.
#+end_comment

#+name:lein-version
#+heading: :results output verbatim
#+heading: :exports both
#+begin_src sh
lein --version
#+end_src

#+begin_example
(defproject leiningen.org "1.0.0"
  :description "Generate static HTML for https://leiningen.org"
  :dependencies [[enlive "1.0.1"]
                 [cheshire "4.0.0"]
                 [org.markdownj/markdownj "0.3.0-1.0.2b4"]]
  :main leiningen.web)
#+end_example

** Leiningen Installation Instructions

#+cindex:installation, Leiningen
#+cindex:Leiningen, install
#+cindex:OpenJDK, require
#+cindex:Java, require
#+cindex:requirement, Java
Leiningen and Clojure require Java.  OpenJDK version 8 is recommended at this
time.

#+cindex:lein script
1. Download the [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] (or on Windows =lein.bat=)

2. Place it on your =$PATH= where your shell can find it (eg. =~/bin=)

3. Set it to be executable (=chmod a+x ~/bin/lein=)

4. Run it (~lein~) and it will download the self-install package

** Leiningen Tutorial

#+cindex:Leiningen tutorial
#+cindex:tutorial, Leiningen
You can read the tutorial by running from the command line:
: lein help tutorial

- [[https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md][Tutorial source code on GitHub]]


#+cindex:features, Leiningen
Leiningen is for automating Clojure projects.  It offers various
project-related tasks and can:

- create new projects
- fetch dependencies for your project
- run tests
- run a fully-configured REPL
- compile Java sources (if any)
- run the project (if the project isn't a library)
- generate a maven-style "pom" file for the project for interop
- compile and package projects for deployment
- publish libraries to repositories such as Clojars
- run custom automation tasks written in Clojure (leiningen plug-ins)


#+texinfo:@heading What This Tutorial Covers

#+cindex:tutorial, features
This tutorial will briefly cover
- project structure,
- dependency management,
- running tests,
- the REPL, and
- topics related to deployment.


This tutorial will help you get started and explain Leiningen's take on project
automation and JVM-land dependency management.

*** Leiningen Projects

#+cindex:project
Leiningen works with /projects/. 

#+cindex:@file{project.clj}
#+cindex:metadata
A /project/ is a directory containing a group of Clojure (and possibly Java)
source files, along with a bit of metadata about them.  The metadata is stored
in a file named ~project.clj~ in the project's root directory, which is how you
tell Leiningen about things like:

- Project name
- Project description
- What libraries the project depends on
- What Clojure version to use
- Where to find source files
- What's the main namespace of the app


Most Leiningen tasks only make sense in the context of a project.  Some (for
example, ~repl~ or ~help~) can also be called from any directory.

*** Creating a Leiningen Project

#+cindex:project, new Leiningen
#+cindex:new Leiningen project
#+cindex:@code{lein new}
Generate a new project:
: lein new app <project-name>

#+begin_example
$ lein new app my-stuff

Generating a project called my-stuff based on the 'app' template.

$ cd my-stuff
$ find .
.
./.gitignore
./doc
./doc/intro.md
./LICENSE
./project.clj
./README.md
./resources
./src
./src/my_stuff
./src/my_stuff/core.clj
./test
./test/my_stuff
./test/my_stuff/core_test.clj
#+end_example

#+cindex:template
#+cindex:app template
#+cindex:default template
#+cindex:library
In this example we're using the =app= template, which is intended for an
application project rather than a library.  Omitting the =app= argument will
use the default template, which is suitable for libraries.

#+texinfo:@heading Directory Layout

#+cindex:app directory structure
#+cindex:project directory
#+cindex:namespace
Here we've got your project's README, a ~src/~ directory containing the code, a
~test/~ directory, and a ~project.clj~ file which describes your project to
Leiningen.  The ~src/my_stuff/core.clj~ file corresponds to the ~my-stuff.core~
/namespace/.

#+texinfo:@heading Filename-to-Namespace Mapping Convention

#+cindex:namespace
Note that we use ~my-stuff.core~ instead of just ~my-stuff~ since
single-segment namespaces are discouraged in Clojure.  Also note that
namespaces with dashes in the name will have the corresponding file named with
underscores instead since the JVM has trouble loading files with dashes in the
name.  The intricacies of namespaces are a common source of confusion for
newcomers, and while they are mostly outside the scope of this tutorial you can
[[https://8thlight.com/blog/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html][read up on them elsewhere]].

#+texinfo:@heading @file{project.clj}

#+cindex:@file{project.clj}
Your ~project.clj~ file will start off looking something like this:[fn:1]

#+begin_src clojure :eval no
(defproject my-stuff "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "https://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "https://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]]
  :main ^:skip-aot my-stuff.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
#+end_src

** Leiningen Documentation

#+cindex:help
#+cindex:@code{lein help}
#+cindex:documetation
#+cindex:FAQ
#+cindex:sample @file{project.clj}
#+cindex:@file{project.clj} sample code
- FAQ:
: lein help faq

- Documentation for each individual task:
: lein help $TASK

- See the sample ~project.clj~ file containing a reference of most project
  settings:
: lein help sample

** Leiningen Profiles

#+cindex:profile, Leiningen
See https://github.com/technomancy/leiningen/blob/stable/doc/PROFILES.md

** Deploying Leiningen Projects

#+cindex:deploy Leiningen project
#+cindex:project, deploy Leiningen
See https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md

** Leiningen Plugins

#+cindex:plugin, Leiningen
#+texinfo:@heading Writing Leiningen Plugins

See https://github.com/technomancy/leiningen/blob/stable/doc/PLUGINS.md

#+texinfo:@heading List of Leiningen Plugins

See https://github.com/technomancy/leiningen/wiki/Plugins

* About Clojure Mode

“Emacs support for the Clojure(Script) programming language”

- [[https://github.com/clojure-emacs/clojure-mode][Clojure Mode Home]]


Provides Emacs font-lock, indentation, navigation and refactoring for the
Clojure(Script) programming language.

** Clojure Mode Installation

Available on the major ~package.el~ community maintained repos:
- [[http://stable.melpa.org/][MELPA Stable]]
- [[http://melpa.org/][MELPA]]


MELPA Stable is the recommended repo as it has the latest stable version. MELPA
has a development snapshot for users who don't mind (infrequent) breakage but
don't want to run from a git checkout.

You can install ~clojure-mode~ using the following commands:

: M-x package-refresh-contents
: M-x package-install [RET] clojure-mode [RET]

or if you'd rather keep it in your dotfiles:

#+begin_src emacs-lisp :eval no
(unless (package-installed-p 'clojure-mode)
  (package-install 'clojure-mode))
#+end_src

#+texinfo:@heading Bundled major modes

The ~clojure-mode~ package actually bundles together several major modes:

- ~clojure-mode~ is a major mode for editing Clojure code

- ~clojurescript-mode~ is a major mode for editing ClojureScript code

- ~clojurec-mode~ is a major mode for editing ~.cljc~ source files


All the major modes derive from ~clojure-mode~ and provide more or less the
same functionality.  Differences can be found mostly in the font-locking ---
e.g. ClojureScript has some built-in constructs that are not present in
Clojure.

The proper major mode is selected automatically based on the extension of the
file you're editing.  Having separate major modes gives you the flexibility to
attach different hooks to them and to alter their behavior individually
(e.g. add extra font-locking just to ~clojurescript-mode~).  Note that all
modes derive from ~clojure-mode~, so things you add to ~clojure-mode-hook~ and
~clojure-mode-map~ will affect all the derived modes as well.

** Clojure Mode Configuration

In the spirit of Emacs, pretty much everything you can think of in
~clojure-mode~ is configurable.

To see a list of available configuration options do:
: M-x customize-group RET clojure.

*** Indentation Options

The default indentation rules in ~clojure-mode~ are derived from the community
Clojure Style Guide.  Please, refer to the guide for the general Clojure
indentation rules.

#+texinfo:@subheading Indentation of docstrings

By default multi-line docstrings are indented with 2 spaces, as this is a
somewhat common standard in the Clojure community.  You can however adjust this
by modifying ~clojure-docstring-fill-prefix-width~.  Set it to 0 if you don't
want multi-line docstrings to be indented at all (which is pretty common in
most lisps).

#+texinfo:@subheading Indentation of function forms

The indentation of function forms is configured by the variable
~clojure-indent-style~.  It takes three possible values:

- ~always-align~ (the default)

- ~always-indent~

- ~align-arguments~


#+texinfo:@subheading Indentation of macro forms

The indentation of special forms and macros with bodies is controlled via

- ~put-clojure-indent~, 

- ~define-clojure-indent~ and

- ~clojure-backtracking-indent~.


Nearly all special forms and built-in macros with bodies have special
indentation settings in ~clojure-mode~.  You can add/alter the indentation
settings in your personal config.  See
https://github.com/clojure-emacs/clojure-mode#indentation-of-macro-forms

#+texinfo:@subheading Vertical alignment

You can vertically align sexps with =C-c SPC=.

This can also be done automatically (as part of indentation) by turning on
~clojure-align-forms-automatically~.  This way it will happen whenever you
select some code and hit TAB.

*** Refactoring Support

The available refactorings were originally created and maintained by the
~clj-refactor.el~ team.  The ones implemented in Elisp only are gradually
migrated to ~clojure-mode~.

#+texinfo: @subheading Threading macros related features

See
https://github.com/clojure-emacs/clojure-mode#threading-macros-related-features

#+texinfo:@subheading Cycling things

See https://github.com/clojure-emacs/clojure-mode#cycling-things

#+texinfo:@subheading Convert collection

See https://github.com/clojure-emacs/clojure-mode#convert-collection

#+texinfo:@subheading Let expression

See https://github.com/clojure-emacs/clojure-mode#let-expression

#+texinfo:@subheading Rename ns alias

See https://github.com/clojure-emacs/clojure-mode#rename-ns-alias

#+texinfo:@subheading Add arity to a function

See https://github.com/clojure-emacs/clojure-mode#add-arity-to-a-function

*** Related Packages to Clojure Mode

See https://github.com/clojure-emacs/clojure-mode#related-packages

*** REPL Interaction in Clojure Mode

See https://github.com/clojure-emacs/clojure-mode#repl-interaction

A number of options exist for connecting to a running Clojure process and
evaluating code interactively.

- Basic REPL ::

  - [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] ::

    provides basic interaction with a Clojure REPL process.  It's
       very similar in nature and supported functionality to
       inferior-lisp-mode for Common Lisp.

- [[https://github.com/clojure-emacs/cider][CIDER]] ::

     a powerful Clojure interactive development environment, similar to SLIME
     for Common Lisp.

* About CIDER

“CIDER is the Clojure(Script) Interactive Development Environment that Rocks!”

- [[https://cider.mx][CIDER Home]]

- [[https://github.com/clojure-emacs/cider][CIDER GitHub]]


#+texinfo:@heading Overview

CIDER extends Emacs with support for interactive programming in Clojure.  The
features are centered around ~cider-mode~, an Emacs minor-mode that complements
~clojure-mode~.  While ~clojure-mode~ supports editing Clojure source files,
~cider-mode~ adds support for interacting with a running Clojure process for
compilation, debugging, definition and documentation lookup, running tests and
so on.

** CIDER Installation

The canonical way to install CIDER via Emacs's build-in package manager
(a.k.a. ~package.el~).  Assuming you've setup the required repository
(e.g. MELPA), all you need to do is:

: M-x package-install RET cider RET

** CIDER Quick Start

The simplest way to start CIDER is via =C-c C-x j j=.  This command will spin
an nREPL server and connect CIDER to it.

** CIDER Guide

See https://docs.cider.mx/cider/index.html

*** CIDER Overview

https://docs.cider.mx/cider/index.html

CIDER aims to provide an interactive development experience similar to the one
you’d get when programming in Emacs Lisp, Common Lisp (with SLIME or Sly),
Scheme (with Geiser) and Smalltalk.

Programmers are expected to program in a very dynamic and incremental manner,
constantly re-evaluating existing Clojure definitions and adding new ones to
their running applications.  You never stop/start a Clojure application while
using CIDER --- you’re constantly interacting with it and changing it.

You can find more details about the typical CIDER workflow in the [[https://docs.cider.mx/cider/usage/interactive_programming.html][Interactive
Programming]] section.  While we’re a bit short on video tutorials, you can check
out this [[https://www.youtube.com/watch?v=aYA4AAjLfT0][introduction to CIDER]] to get a feel about what do we mean by an
“Interactive Development Environment”.

#+cindex:nREPL
CIDER’s built on top of [[https://github.com/nrepl/nrepl][nREPL]], the Clojure networked REPL server.

Clojure code gets executed by an nREPL server.  CIDER sends requests to the
server and processes its responses.  The server’s functionality is augmented by
additional [[https://github.com/clojure-emacs/cider-nrepl][nREPL middleware]], designed specifically to address the needs of an
interactive development environment like CIDER.

*** CIDER Up and Running

https://docs.cider.mx/cider/basics/up_and_running.html

To use CIDER, you’ll need to connect it to a running nREPL server that is
associated with your program.  Most Clojure developers use standard build
tooling such as Leiningen, Boot, or Gradle, and CIDER can automatically work
with those tools to get you up and running quickly.  But those tools are not
required; CIDER can connect to an nREPL server that is already started and is
managed separately.[fn:2]

There are two ways to connect CIDER to an nREPL server:

1. CIDER can launch an nREPL server for your project from Emacs.

2. You can connect CIDER to an already-running nREPL server, managed
   separately.

**** Launch an nREPL Server From Emacs

https://docs.cider.mx/cider/basics/up_and_running.html#_launch_an_nrepl_server_from_emacs

#+cindex:nREPL session, launch
If you have a Clojure project in your file system and want CIDER to launch an
nREPL session for it, simply visit a file that belongs to the project, and type:

: M-x cider-jack-in RET

CIDER will start an nREPL server and automatically connect to it.

#+cindex:@code{cider-jack-in} command
In Clojure(Script) buffers the command ~cider-jack-in~ is bound to

: C-c C-x (C-)j (C-)j

The process of jacking-in is pretty simple:

- CIDER shells out and runs a command like ~lein repl :headless~.

- CIDER waits for the nREPL server to start.  CIDER figures out this by parsing
  the output from the command and waiting for a line like =nREPL server started
  on port 53005 on host localhost -- nrepl://localhost:53005= to appear there.

- CIDER extracts the port of the nREPL from the preceding message.

- It connects to the running nREPL server.


#+texinfo:@heading Auto-Injecting Dependencies

While CIDER’s core functionality requires nothing more than an nREPL server,
there are many advanced features that depend on the presence of additional
nREPL middleware.  In the early versions of CIDER (up to CIDER 0.11) users had
to add those dependencies themselves, which was a painful and error-prone
process.  Fortunately today that’s handled auto-magically when you’re using
~cider-jack-in~.

If your project uses ~lein~, ~boot~ or ~tools.deps~ (~deps.edn~), CIDER will
automatically inject all the necessary nREPL dependencies (e.g. ~cider-nrepl~
or ~piggieback~) when it starts the server.  The injection process is extremely
simple --- CIDER simply passes the extra dependencies and nREPL configuration
to your build tool in the command in runs to start the nREPL server.  Here’s
how this looks for ~tools.deps~:

#+begin_example
$ clojure -Sdeps '{:deps {nrepl {:mvn/version "0.6.0"} cider/cider-nrepl {:mvn/version "0.22.4"}}}' 
  -m nrepl.cmdline 
  --middleware '["cider.nrepl/cider-middleware"]'
#+end_example

Normally ~cider-jack-in~ would inject only ~cider-nrepl~ and
~cider-jack-in-cljs~ would add ~piggieback~ as well.  The injection mechanism
is configurable and you can easily add more libraries there.  Some CIDER
extensions would use this mechanism to auto-inject their own dependencies.

#+texinfo:@subheading Jacking-in without a Project

If you try to run ~cider-jack-in~ outside a project directory, CIDER will warn
you and ask you to confirm whether you really want to do this; more often than
not, this is an accident.  If you decide to proceed, CIDER will invoke the
command configured in ~cider-jack-in-default~.  Prior to CIDER 0.17, this
defaulted to ~lein~ but was subsequently switched to ~clj~, Clojure’s basic
startup command.

#+texinfo:@subheading Customizing the Jack-in Command Behaviour

You can use =C-u M-x cider-jack-in RET= to specify the exact command that
~cider-jack-in~ would run.  This option is very useful is you want to specify a
something like a ~lein~ or ~deps.edn~ profile.

Alternatively you can =C-u C-u M-x cider-jack-in RET=, which is a variation of
the previous command.  This command will first prompt you for the project you
want to launch ~cider-jack-in~ in, which is pretty handy if you’re in some
other directory currently.  This option is also useful if your project contains
some combination of ~project.clj~, ~build.boot~ and ~deps.edn~ and you want to launch
a REPL for one or the other.

**** Connect to a Running nREPL Server

https://docs.cider.mx/cider/basics/up_and_running.html#_connect_to_a_running_nrepl_server

If you have an nREPL server already running, CIDER can connect to it.  For
instance, if you have a Leiningen-based project, go to your project’s directory
in a terminal session and type:

: $ lein repl :headless

This will start the project’s nREPL server.

If your project uses boot, do this instead:

: $ boot repl -s wait (or whatever task launches a repl)

It is also possible for plain clj, although the command is somewhat longer:

: $ clj -Sdeps '{:deps {cider/cider-nrepl {:mvn/version "0.21.1"}}}'
:   -m nrepl.cmdline --middleware "[cider.nrepl/cider-middleware]"

Alternatively, you can start nREPL either manually or using the facilities
provided by your project’s build tool (Gradle, Maven, etc).

After you get your nREPL server running, go back to Emacs and connect to it:
=M-x cider-connect RET=.  CIDER will prompt you for the host and port
information, which should have been printed when the previous commands started
the nREPL server in your project.

In Clojure(Script) buffers the command cider-connect is bound to =C-c C-x c s=.

If you frequently connect to the same hosts and ports, you can tell CIDER about
them and it will use the information to do completing reads for the host and
port prompts when you invoke cider-connect. You can identify each host with an
optional label.

#+begin_src emacs-lisp :eval no
(setq cider-known-endpoints
  '(("host-a" "10.10.10.1" "7888")
    ("host-b" "7888")))
#+end_src

*** TODO CIDER Interactive Programming

https://docs.cider.mx/cider/usage/interactive_programming.html

** CIDER Features

#+texinfo:@heading Code Completion

CIDER provides smart code completion for Clojure and ClojureScript.

#+texinfo:@heading Enhanced REPL

CIDER provides a super-charged REPL experience with all the bells and whistles
you can imagine.

#+texinfo:@heading Definition and Documentation Lookup

CIDER provides powerful code and documentation lookup facilities.

#+texinfo:@heading Human-friendly Error Messages

CIDER tries to present Clojure's notorious stacktraces in a manner that's less
intimidating and more informative.

#+texinfo:@heading Interactive Debugger

CIDER tries to present Clojure's notorious stacktraces in a manner that's less
intimidating and more informative.

#+texinfo:@heading Test Integration

CIDER gives you the ability to run your tests without ever leaving your editor.

* Build Tools
:PROPERTIES:
:appendix: t
:END:

** Makefile                                          :dependencies:env_vars:
:PROPERTIES:
:appendix: t
:dependency1: "make"
:dependency2: "AWS Account with ~/.aws/credentials and ~/.aws/config"
:dependency3: "S3 bucket set up for serving a static web pages"
:dependency4: "GitHub Account with personal token"
:env_var1: ORG_TEMPLATE
:env_var2: EMACSLOADPATH
:env_var3: AWS_S3_BUCKET
:env_var4: GITHUB_TOKEN
:END:

#+name:Makefile
#+header: :tangle Makefile
#+header: :noweb tangle
#+begin_src makefile
  ### USER-DEPENDENT VARIABLES
  ### USE ENVIRONMENT VARIABLES FOR SENSITIVE DATA
  ### ALL OTHERS CAN BE HARD-CODED
  ### YOU ALSO NEED ~/.aws/credentials

  EMACS    = /Applications/MacPorts/EmacsMac.app/Contents/MacOS/bin/emacs-26.3
  EMACS-D  = $(HOME)/.emacs.d
  INIT-EL  = init.el

  # the location of this file
  TEMPLATE = $(ORG_TEMPLATE)

  # your personal GitHub token for authentication
  TOKEN    = $(GITHUB_TOKEN)

  # the AWS S3 bucket to use to store Org source files
  BUCKET   = s3://$(AWS_S3_BUCKET)

  # your aws command; this program uses the new version
  AWS      = aws2

  # your AWS region of choice
  REGION   = --region us-west-2

  ### END OF USER-DEPENDENT VARIABLES

  ### PROGRAM
  PROJ   = <<get-org-filename()>>

  # DIR is not necessarily the same as PROJ; it is the exported .texi and .info filename
  DIR    = <<get-org-lc-filename()>>

  # VERS needs to be dynamic in case the version number is updated but the Makefile stays static during sync
  VERS   = $(shell sed -Ene '/^\#\+macro:version Version ([[:digit:][:punct:]]{1,3})/ { s//v\1/p; q; }' $(ORG))/
  S3VERS = <<get-s3-version()>>
  USER   = <<get-github-user-info('login')>>

  ### TOOLS & RESOURCES
  TOOLS  = tools
  CMPRPL = $(TOOLS)/cmprpl
  SAVE   = resources

  ### TEXINFO
  ORG   = $(PROJ).org
  TEXI  = $(PROJ).texi
  INFO  = $(DIR).info
  PDF   = $(PROJ).pdf
  HTML  = $(DIR)/index.html
  INDEX = index.html
  DIR_OLD= $(DIR)-old

  ### AWS
  S3     = $(AWS) s3
  SRC    = $(DIR)/

  DST_OLD = $(BUCKET)/$(DIR)-$(S3VERS)
  DST_NEW = $(BUCKET)/$(DIR)-$(VERS)
  EXCL_INCL = --exclude "*" --include "*.html"
  GRANTS  = --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  S3SYNC  = $(S3) sync $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE  = $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)

  default: check texi info html pdf

  PHONY: check default all \
	  texi info html pdf \
	  open-org open-texi open-html open-pdf \
	  clean dist-clean wiped-clean \
	  help sync update values

  values: check
	  @echo USER:	$(USER)
	  @echo PROJ:	$(PROJ)
	  @echo VERS:	$(VERS)
	  @echo S3VERS:	$(S3VERS)
	  @echo DIR:	$(DIR)
	  @echo DIR_OLD:	$(DIR_OLD)
	  @echo SRC:	$(SRC)
	  @echo DST_OLD:	$(DST_OLD)
	  @echo DST_NEW:	$(DST_NEW)

  check:
	  @[[ -z $${AWS_S3_BUCKET} ]] && \
	     { printf "$${RED}\$$AWS_S3_BUCKET $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${GREEN}AWS_S3_BUCKET: $${CYAN}$${AWS_S3_BUCKET}$${CLEAR}\n";
	  @[[ -z $${GITHUB_TOKEN} ]] && \
	     { printf "$${RED}GITHUB_TOKEN $${CYAN}must be set.$${CLEAR}\n"; exit 1; } || \
	     printf "$${GREEN}GITHUB_TOKEN: set$${CLEAR}\n";
	  @[ -d ~/.aws -a -f ~/.aws/credentials -a -f ~/.aws/config ] && \
	     printf "$${GREEN}~/.aws credentials and config: set$${CLEAR}\n" || \
	     { printf "$${RED}~/.aws 'credentials' and 'config' must be set.$${CLEAR}\n"; exit 1; }
	    @$(EMACS) --batch --load="$(EMACS-D)/$(INIT-EL)" --eval \
	      '(progn \
		  (if \
		    (member (quote texinfo) org-export-backends) \
		    (princ "texinfo backend: INSTALLED in org-export-backends") \
		    (princ "texinfo backend: NOT INSTALLED in org-export-backends")) \
		  (terpri) \
		  (if \
		     org-confirm-babel-evaluate \
		     (princ "org-confirm-babel-evaluate: SET to t; consider setting to nil") \
		     (princ "org-confirm-babel-evaluate: SET to nil")) \
		  (terpri))'

  open-org: $(ORG)
	  emacsclient $(ORG) &
  $(ORG):
	  @echo 'THERE IS NO $(ORG) FILE!!!'
	  exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	  $(EMACS) --batch --eval '\
	  (progn \
	    (require (quote org)) \
	    (require (quote ob-shell)) \
	    (setq org-confirm-babel-evaluate nil) \
	    (find-file "$(ORG)") \
	    (org-texinfo-export-to-texinfo))'

  open-texi: texi
	  emacsclient $(TEXI) &

  info: $(INFO)
  $(INFO): $(TEXI)
	  makeinfo $(TEXI)

  html: $(HTML)
  $(HTML): $(TEXI)
	  makeinfo --html $(TEXI)
	  $(CMPRPL) $(DIR) $(DIR_OLD)
  open-html: html
	  open $(HTML)

  pdf: $(PDF)
  $(PDF): $(TEXI)
	  pdftexi2dvi --quiet --build=clean $(TEXI)
  open-pdf: pdf
	  open $(PDF)

  sync: $(HTML)
	  $(S3SYNC)
	  [[ $(VERS) != $(S3VERS) ]] && { $(S3MOVE); make homepage; } || :

  homepage: $(ORG)
	  curl -i \
	       -H "Authorization: token $(TOKEN)" \
	       -H "Content-Type: application/json" \
	       -X PATCH \
	       -d '{"homepage":"https://$(AWS_S3_BUCKET)/$(DIR)-$(VERS)"}' \
	       https://api.github.com/repos/$(USER)/$(PROJ)

  update: $(ORG)
	  $(EMACS) -Q --batch --eval \
	  '(progn \
	     (require (quote org)) \
	     (require (quote ob)) \
	     (require (quote ob-shell)) \
	     (find-file "$(TEMPLATE)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-copy-subtree) \
	     (kill-buffer) \
	     (find-file "$(ORG)") \
	     (goto-char (point-min)) \
	     (search-forward "* Build Tools") \
	     (org-beginning-of-line) \
	     (org-yank) \
	     (org-cut-subtree) \
	     (save-buffer) \
	     (kill-buffer) \
	     (setq org-confirm-babel-evaluate nil) \
	     (org-babel-tangle-file "$(ORG)"))'

  clean:
	  -rm *~

  dist-clean: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)
	  -for dir in *; \
	   do \
		  [ -d $$dir -a $$dir != "$(DIR_OLD)" -a $$dir != $(SAVE) ] && \
		  rm -vr $$dir; \
	   done

  wiped-clean: dist-clean
	  -rm -rf Makefile $(DIR_OLD)

  help:
	  @echo '"make default" makes the .texi file, the .info file, \
	  the html files, and the .pdf file.'
	  @echo

	  @echo '"make check" checks for prerequistes'
	  @echo '"make values" runs check and prints variable values'
	  @echo

	  @echo '"make sync" syncs the html files in the AWS S3 bucket BUCKET; \
	  you must have your AWS S3 bucket name in the env var AWS_S3_BUCKET; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make clean-dist" cleans, removes the html distribution, \
	  and removes the build directory'

#+end_src

*** TODO Next
1. The CloudFront configuration needs to be updated recognize the new version
   directory that is created as part of the ~sync~ operation.

2. Update the GitHub HOME website link for each new sync operation.

3. Store on GitHub a version of each other format upon a sync operation (i.e.,
   the INFO and PDF versions)

** Get Org Filename
This program simply uses the name of the buffer to obtain the name of the
filename to add to the Makefile.

#+caption:Get Org Filename program
#+name:get-org-filename
#+begin_src emacs-lisp :eval yes
(file-name-base)
#+end_src

** Get Org Lowercase Filename
This code looks for the =#+TEXINFO_FILENAME:= in the =#+TEXINFO EXPORTS=
subtree.  If it doesn’t exist, then it will use the lower-cased filename as a
fallback default.

#+caption:Get Org Lowercase Filename program
#+name:get-org-lc-filename
#+header: :results value
#+begin_src emacs-lisp :eval yes
  (save-excursion
    (if
        (re-search-forward "^[[:space:]]*#\\+texinfo_filename:\\(.*\\)" nil t)
        (file-name-sans-extension (match-string 1))
      (downcase (file-name-base))))
#+end_src

** Get File Version
This program scans the current buffer for the version number and places it into
the Makefile.

#+caption:Get File Version program
#+name:get-file-version
#+begin_src emacs-lisp :eval yes
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^#\\+macro:version Version \\(\\(?:[[:digit:]]+\\.?\\)\\{3\\}\\)")
    (concat "v" (match-string-no-properties 1) "/"))
#+end_src

** Get S3 List of Programs
This script obtains the list of programs and their version numbers residing in
the S3 bucket.  It returns an alist of the form ~((prog . ver))~.

** Get S3 Version
:PROPERTIES:
:dependency: ">= bash v4"
:END:
This program obtains the version number of the code currently uploaded to the
S3 bucket by obtaining a directory listing of top-level directories, which are
in the form ~PRE <dir>-v#.#.#/~, and performs a regular expression search with
a parenthesized match on the version numbers.  The program will exit with 'nil'
if there is no match, but will return the version number as a string if there
is a match.

Note that the regular expression matching requires at least Bash version 4 or
above.

#+caption:Get S3 Version
#+name:get-s3-version
#+header: :var dir=get-org-lc-filename()
#+header: :var file_version=get-file-version()
#+header: :results output
#+header: :eval yes
#+header: :shebang "#! /usr/bin/env bash"
#+begin_src sh
  if [[ ${file_version} = "v0.0.0/" ]]
  then
      echo -n "nil"

  else
      re=${dir}'-(v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)'

      # obtain a list of directories in the aws s2 bucket
      verpre=$(aws2 s3 ls s3://${AWS_S3_BUCKET}/)

      # check for a match; if one, return the version number; else return 'nil'
      if [[ $verpre =~ $re ]]
      then
		echo -n ${BASH_REMATCH[1]}/
      else
		echo -n "nil"
      fi
  fi
#+end_src

#+caption:Get S3 Elisp Version
#+name:get-s3-elisp-version
#+header: :var dir=get-org-lc-filename()
#+header: :var file_version=get-file-version()
#+header: :results output
#+header: :eval yes
#+begin_src emacs-lisp
  (setq re ; regexp of the form <dir>-v1.23.45/, extracting v1.23.45/
	(concat
	 (regexp-quote dir) ; <== use :var dir here
	 "-\\(v\\(?:[[:digit:]]+\\.?\\)\\{3\\}\\)\\/"))

  (setq str ; aws s3 ls s3://<bucket>; obtains string of directories-versions
	(shell-command-to-string
	 (concat
	  "aws2 s3 ls s3://"
	  (substitute-in-file-name "$AWS_S3_BUCKET")))) ; <== use env var here

  (if (string= file_version "v0.0.0/") ; <== use :var file-version here
      nil
    (progn
      (string-match re str) ; str =~ /re/, match using this directory
      (princ
       (match-string-no-properties 1 str)))) ; print the first subexpression, e.g. v1.23.45
#+end_src

#+RESULTS: get-s3-elisp-version
: v0.1.9

** Get GitHub User Info
This code calls the GitHub API from ~curl~ using the token stored in the env
var =GITHUB_TOKEN= to obtain the GitHub user’s information.  The user’s
information is returned as a JSON string.  Ths code returns one of the values
based on a given key.  The default key used is =html_url=, but you can ask for
any valid key by supplying an argument in the invocation, such as:
: get-github-user-info(login)

#+name:get-github-user-info
#+header: :var key="html_url"
#+begin_src sh :eval yes :results value
  node -pe 'JSON.parse(process.argv[1]).'$key "$(curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user)"
#+end_src

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.  This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=.  It also makes sure there is a
Makefile on an initial export.  The following code is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: $DIR_NEW.  If it
doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, $DIR_OLD.  If one doesn’t,
then one is created by copying the current new directory.  This provides a
baseline for comparisons going forward.  The program exits at that point.

Given that $DIR_OLD exists, the program then loops through all files in $DIR_OLD
and compares them to the files in $DIR_NEW.  If the files are identical, the
$DIR_OLD file replaces the $DIR_NEW file while retaining the old time stamp.  If
a file is different, then the $DIR_NEW file replaces the $DIR_OLD file, thus
giving it updated content and an updated time stamp.

The program then loops through all of the files in the new directory and copies
any that do not exist in the old directory.  Now both directories should be in
sync.

It is important to retain the $DIR_OLD directory for as long as possible to reap
the most benefits from the AWS S3 ~sync~ command.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  DIR_NEW=$1
  DIR_OLD=$2

  [[ -d $DIR_NEW ]] || { echo "ERROR: $DIR_NEW does not exist"; exit 1; }
  [[ -d $DIR_OLD ]] || { echo "CREATING: $DIR_OLD does not exist"; cp -a $DIR_NEW $DIR_OLD; exit 0; }

  for oldfile in $DIR_OLD/*
  do
      newfile=$DIR_NEW/$(basename $oldfile)
      if [[ -e $newfile ]]
      then
	      if cmp -s $newfile $oldfile
	      then
	          printf "${GREEN}copying OLD to NEW${CLEAR}: "
	          cp -vp $oldfile $newfile
	      else
	          printf "${PURPLE}copying NEW to OLD${CLEAR}: "
	          cp -vp $newfile $oldfile
	      fi
      else
	      printf "${RED}removing OLD:${CLEAR} "
	      rm -v $oldfile
      fi
  done

  for newfile in $DIR_NEW/*
  do
      oldfile=$DIR_OLD/$(basename $newfile)
      [[ -e $oldfile ]] || { printf "${BLUE}adding NEW to OLD${CLEAR}: "
			     cp -vp $newfile $oldfile; }
  done
#+end_src


* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:


* Footnotes

[fn:3] 

[fn:1]Org requires [[https://github.com/clojure-emacs/clojure-mode][Clojure-mode]] to work with clojure source code.  Clojure mode
provides Emacs font-lock, indentation, navigation and refactoring for the
Clojure(Script) programming language.



[fn:2]CIDER will automatically work with Leiningen 2.9.0+ or Boot 2.8.3+.
Older versions are not supported.

* Export Configurations                                            :noexport:
#+texinfo_filename:clojure.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Programming Languages
#+texinfo_dir_title:Clojure
#+texinfo_dir_desc:All about the elegant language of Clojure
#+texinfo_printed_title:All About Clojure


* Local Variables                                                  :noexport:

# Local Variables:
# fill-column: 79
# indent-tabs-mode: t
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (electric-quote-local-mode)
# End:
