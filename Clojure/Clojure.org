# -*- mode:org; -*-

#+title:Clojure
#+subtitle:{{{version}}} {{{date}}}
#+author:Pinecone062
#+date:2020-01-07 19:54
#+macro:version Version 0.0.2

/{{{title}}}/ {{{version}}} compiled {{{date}}}

#+texinfo:@insertcopying


* Introduction
:PROPERTIES:
:unnumbered: t
:END:
* Clojure for Brave and True
:PROPERTIES:
:url: https://www.braveclojure.com
:author:   "Daniel Higginbotham"
:author-blog: http://flyingmachinestudios.com
:reviewer-blog: http://tailrecursion.com/~alan
:copyright: 2015
:publisher: "No Starch Press"
:isbn:     1-59327-591-9
:isbn-13:  978-1-59327-591-4
:END:

** Forward
#+cindex:John McCarthy
#+cindex:Lisp
You will eventually learn through reading this book that programming is more
enjoyable after knowing some Clojure.  Clojure is the most elegant programming
language every designed.  Elegance is a quality regularly ascribed to many
dialects in the family of programming languages known collectively as Lisp, or
which Clojure is one.   All Lisps descend from a set of siimple and beautiful
discoveries made by the mathematician John McCarthy in 1958.

** Introduction
:PROPERTIES:
:unnumbered: t
:END:

*** Learning a New Programming Language---A Journey through the Four Labyrinths
To wield Clojure to its fullest, you’ll need to find your way through the four
labyrinths that face every programmer learning a new language:

#+attr_texinfo: :indic b
- The Forest of Tooling ::

     A friendly and efficient programming environment makes it easy to try your
     ideas.  You’ll learn how to set up your environment.

- The Mountain of Language ::

     As you ascend, you’ll gain knowledge of Clojure’s syntax, semantics, and
     data structures.  You’ll learn how to use one of the mightiest programming
     tools, the macro, and learn how to simplify your life with Clojure’s
     concurrency constraints.

- The Cave of Artifacts ::

     In its depths, you’ll learn to build, run, and distribute your own
     programs, and how to use code libraries.  You’ll also learn Clojure’s
     relationship to the Java Virtual Machine (JVM).

- The Cloud Castle of Mindset ::

     In its rarefied air, you’ll come to know they why and how of Lisp and
     functional programming.  You’ll learn about the philosophy of simplicity
     that permeates Clojure, and how to solve problems like a Clojurist.


This book follows three guidelines:

1. It takes the dessert-first approach, giving you the development tools and
   language details you need to start playing with real programs immediately.

2. It assumes zero experience with the JVM, functional programming, or Lisp.
   It covers these topics in detail so you’ll feel confident about what you’re
   doing when you build and run Clojure programs.

3. It eschews /real-world/ examples in favor of more interesting exercises,
   like /assaulting hobbits/ and /tracking glittery vampires/.


By the end, you’ll be able to use Clojure.

*** How this Book is Organized

This book is split into three parts to better guide you through your valient
quest, brave fledgling Clojurist.

#+texinfo:@heading Part I---Environment Setup

Theswe chapters take you on a quick tour of the tools you’ll need to easily
write programs.

#+texinfo:@subheading Chapter 1---Building-Running-and the REPL

There’s something powerful and motivating about getting a real program
running.  Once you can do that, you’re free to experiment, and you can actually
share your work!

In this chapter, you’ll invest a small amount of time to become familiar with a
quick way to build and run Clojure programs.  You’ll learn how to experiment
with code in a running Clojure process using a read-eval-print loop (REPL).
This will tighten your feedback loop and help you learn more efficiently.

#+texinfo:@subheading How to use Emacs---an excellent Clojure Editor

A quick feedback loop is crucial for learning.  In this chapter, I cover Emacs
from the ground up to guarantee you have an efficient Emacs/Clojure workflow.

#+texinfo:@heading Part II---Language Fundamentals

These chapters give you a solid foundation on which to continue learning
Clojure.  You’ll start by learning Clojure’s basics (syntax, semantics, and
data structures) so you can /do things/.  Then you’ll take a step back to
examine Clojure’s most used functions in detail and learn how to solve problems
with them using the /functional programming/ mindset.

#+texinfo:@subheading Chapter 3---Do Things---a Clojure Crash Course

Clojure’s most salient characteristic is that it is a Lisp.  You’ll explore
this Lisp core, which is composed of two parts: functions and data.

#+texinfo:@subheading Chapter 4---Core Functions in Depth

In this chapter you’ll learn about a couple of Clojure’s underlying concepts.
This will give you the grounding you need to read the documentation for
functions you haven’t used before and to understand what’s happening when you
try them.

You’ll also see usage examples of the functions you’ll be reading for the
most.  This will give you a solid foundation for writing your own code and for
reading and learning from other people’s projects.

#+texinfo:@subheading Chapter 5---Functional Programming

In this chapter, you’ll take your concrete experience with functions and data
structures and integrate it with a new mindset: the functional programming
mindset.

#+texinfo:@subheading Chapter 6---Organizing your Project---A Librarian’s Tale

This chapter explains what namespaces are and how to use them to organize your
code.

#+texinfo:@subheading Chapter 7---Clojure Alchemy---Reading, Evaluation, and Macros

In this chapter, you’ll take a step back and describe how Clojure runs your
code.  This will give you the conceptual structure you need to truly understand
how Clojure works and how it’s different from other, non-Lisp languages.  With
this structure in place, I’ll introduce the macro, one of the most powerful
tools in existence.

#+texinfo:@subheading Writing Macros

This chapter thoroughly examines how to write macros, starting with basic
examples and advancing in complexity.

#+texinfo:@heading Part III---Advanced Topics

These chapters cover Clojure’s extra-fun topics---concurrency, Java interop and
abstraction.  Although you can write programs without understanding these tools
and concepts, they’re intellectually rewarding and give you tremendous power as
a programmer.  One of the reasons people say that learning Clojure makes you a
better programmer is that it makes the concepts covered in these chapters easy
to understand and practical to use.

#+texinfo:@subheading Chapter 9---The Sacred Art of Concurrent and Parallel Programming

In this chapter you’ll learn what concurrency and parallelism are and why they
matter.  You’ll learn about challenges you’ll face when writing parallel
programs and about how clojure’s design helps to mitigate them.  You’ll use
futures, delays, and promises to safely write parallel programs.

#+texinfo:@subheading Chapter 10---Clojure Metaphysics---Atoms, Refs, Vars, and Cuddle Zombies

This chapter goes into great detail about Clojure’s approach to managing state
and how that simplifies concurrent programmibng.  You’ll learn how to use
atoms, refs, and vars, three constructs for managing state, and you’ll learn
how to do stateless parallel computation with ~pmap~.  And there will be cuddle
zombies.

#+texinfo:@subheading Chapter 11---Mastering Concurrent Processes with ~core.async~

In this chapter, you’ll ponder the idea that everything in the univese is a hot
dog vending machine.  By which I mean you’ll learn how to model systems of
independently running processes that communicate with each other over channels
using the ~core.async~ library.

#+texinfo:@subheading Chapter 12---Working with the JVM

This chapter is like a phrase book and cultural introduction to the Land of
Java.  It gives you an overview of what the JVM is, how it runs programs, and
how to compile programs for it.  It also gives you a brief tour of frequently
used Java classes and methods, and explains how to interact with them from
Clojure.  It shows you how to think about and understand Java so you can
incorporate any Java library into your Clojure program.

#+texinfo:@subheading Chapter 13---Creating and Extending Abstractions with Multimethods, Protocols, and Records

This chapter serves as an introduction to the world of cereating and
implementing your own abstractions.  You’ll learn the basics of multimethods,
protocols, and records.

#+texinfo:@heading Appendix A---Building and Developing with Leiningen

This appendix clarifies some of the finer points of working with Leiningen,
like what Maven is and how to figure out the version numbers of Java libraries
so you can use them.

#+texinfo:@heading Appendix B---Boot, the Fancy Clojure Build Framework

Boot is an alternative to Leiningen that provides the same functionality, but
with the added bonus that its easier to extend and write composable tasks.
This appendix explains Boot’s underlying concepts and guides you through
writing your first tasks.

*** The Code

You can download all the source code from the book at
https://github.com/braveclojure/cftbat-code/.  The code is organized by
chapter.

Chapter 1 describes the different ways tht you can run Clojure code, including
how to use a REPL.  I recommend running most of the examples in the REPL as you
encounter them.  This will help you get used to writing and understanding Lisp
code, and it will help you retain everything you’re learning.  But for the
examples that are long, it’s best to write the code to a file, and then run the
code you wrote in a REPL.

*** The Journey Begins!

** Building Running and REPL

** How to use Emacs
** Clojure Crash Course
** Core Functions in Depth
** Functional Programming
** Organizing Your Project
** Reading Evaluation and Macros
** Writing Macros
** Concurrent and Parallel Programming
** Atoms---Refs---Vars---Cuddle Zombies
** Mastering Concurrent Processes with core.async
** Working with the JVM
** Creating and Extending Abstractions with Multimethods-Protocols-and Records
** Building and Developing with Leiningen
** Boot---Clojure Build Framework
** Farewell

* Build Tools
:PROPERTIES:
:appendix: t
:END:
** Makefile
:PROPERTIES:
:appendix: t
:END:
#+name:Makefile
#+header: :tangle Makefile
#+header: :noweb tangle
#+begin_src makefile
  ### PROGRAM
  PROG   = <<get-org-filename()>>
  DIR    = <<get-org-lc-filename()>>
  VERS   = <<get-file-version()>>
  S3VERS = <<get-s3-version()>>

  ### TOOLS
  TOOLS = tools
  CMPRPL = $(TOOLS)/cmprpl

  ### TEXINFO
  ORG   = $(PROG).org
  TEXI  = $(PROG).texi
  INFO  = $(PROG).info
  PDF   = $(PROG).pdf
  HTML  = $(DIR)/index.html

  ### HTML DIR
  OLDDIR= $(DIR)-old
  INDEX = index.html

  ### AWS
  HOME = s3://$(AWS_BUCKET)
  AWS  = aws2
  S3   = $(AWS) s3
  SRC  = $(DIR)/

  DST_OLD = $(HOME)/$(DIR)-$(S3VERS)
  DST_NEW = $(HOME)/$(DIR)-$(VERS)
  EXCL_INCL = --exclude "*" --include "*.html"
  GRANTS = --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers
  REGION = --region us-west-2
  S3SYNC = $(S3) sync $(EXCL_INCL) $(SRC) $(DST_OLD) $(REGION) $(GRANTS)
  S3MOVE = $(S3) mv --recursive $(DST_OLD) $(DST_NEW) $(REGION) $(GRANTS)

  default: texi info html pdf

  PHONY: default all texi info html pdf open-org open-texi open-html \
	   open-pdf clean clean-dist help sync

  show-version:
	  @echo EMACSLOADPATH $(EMACSLOADPATH)
	  @echo AWS_BUCKET $(AWS_BUCKET)
	  @echo PROG $(PROG)
	  @echo VERS $(VERS)
	  @echo S3VERS $(S3VERS)
	  @echo DIR $(DIR)
	  @echo OLDDIR $(OLDDIR)
	  @echo SRC $(SRC)
	  @echo DST_OLD $(DST_OLD)
	  @echo DST_NEW $(DST_NEW)

  open-org: $(ORG)
	  emacsclient $(ORG) &
  $(ORG):
	  @echo 'DISASTER HAS BEFALLEN YOU AS THERE IS NO $(ORG) FILE!!!'
	  exit 1

  texi: $(TEXI)
  $(TEXI): $(ORG)
	  emacs --batch --eval '\
	  (progn \
	    (require '\''org) \
	    (require '\''ob) \
	    (require '\''ox-texinfo) \
	    (require '\''ob-shell) \
	    (setq org-confirm-babel-evaluate nil) \
	    (find-file "$(ORG)") \
	    (org-export-to-file '\''texinfo "$(TEXI)"))'

  open-texi: texi
	  emacsclient $(TEXI) &

  info: $(INFO)
  $(INFO): $(TEXI)
	  makeinfo $(TEXI)

  html: $(HTML)
  $(HTML): $(TEXI)
	  makeinfo --html $(TEXI)
	  $(CMPRPL) $(DIR) $(OLDDIR)
  open-html: html
	  open $(HTML)

  pdf: $(PDF)
  $(PDF): $(TEXI)
	  pdftexi2dvi --quiet --build=clean $(TEXI)
  open-pdf: pdf
	  open $(PDF)

  sync: $(HTML)
	  $(S3SYNC)
	  [[ $(VERS) != $(S3VERS) ]] && $(S3MOVE) || :

  clean:
	  -rm *~

  clean-dist: clean
	  -rm -rf *.{texi*,info*,html*,pdf*} $(DIR) $(TOOLS)

  help:
	  @echo '"make default" makes the .texi file \
	  the html files, and opens the index.html file'
	  @echo

	  @echo '"make all" makes the .texi, .info, .pdf, and html distribution'
	  @echo '"make sync" syncs the html files in the AWS S3 bucket HOME; \
	  You must have your AWS credentials installed in ~/.aws/credentials'
	  @echo

	  @echo '"make texi" makes the .texi file'
	  @echo '"make info" makes the .info file'
	  @echo '"make html" makes the html distribution in a subdirectory'
	  @echo '"make pdf" makes the .pdf file'
	  @echo

	  @echo '"make open-org" opens the ORG program using emacsclient for editing'
	  @echo '"make open-texi" opens the .texi file using emacsclient for review'
	  @echo '"make open-html" opens the distribution index.html file \
	  in the default web browser'
	  @echo '"make open-pdf" opens the .pdf file'
	  @echo

	  @echo '"make clean" removes the .texi, .info, and backup files ("*~")'
	  @echo '"make clean-dist" cleans, removes the html distribution, \
	  and removes the build directory'

#+end_src
** Get Org Filename
This program simply uses the name of the buffer to obtain the name of the
filename to add to the Makefile.

#+caption:Get Org Filename program
#+name:get-org-filename
#+begin_src emacs-lisp :eval yes
(file-name-base)
#+end_src

** Get Org Lowercase Filename
This program simply downcases the buffer filename to use as a directory name
for the HTML output.

#+caption:Get Org Lowercase Filename program
#+name:get-org-lc-filename
#+begin_src emacs-lisp :eval yes
(downcase (file-name-base))
#+end_src

** Get File Version
This program scans the current buffer for the version number and places it into
the Makefile.

#+caption:Get File Version program
#+name:get-file-version
#+begin_src emacs-lisp :eval yes
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "^#\\+macro:version Version \\(\\(?:[[:digit:]]+\\.?\\)\\{3\\}\\)")
    (concat "v" (match-string-no-properties 1) "/"))
#+end_src

** Get S3 Version
:PROPERTIES:
:dependency: ">= bash v4"
:END:
This program obtains the version number of the code currently uploaded to the
S3 bucket by obtaining a directly listing of top-level directories, which are
in the form ~PRE <dir>-v#.#.#/~, and performs a regular expression search with
a parenthesized match on the version numbers.  The program will exit with an
error if there is no match, but will return the version number as a string if
there is a match.

Note that the regular expression matching requires at least Bash version 4 or
above.

#+caption:Get S3 Version
#+name:get-s3-version
#+header: :var dir=get-org-lc-filename()
#+header: :var file_version=get-file-version()
#+begin_src sh :eval yes
  [[ ${file_version} = v0.0.0/ ]] && { echo "nil"; exit 0; }
  re=${dir}'-(v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)'
  verpre=$(aws2 s3 ls s3://pinecone-forest.com/) ### TODO
  [[ $verpre =~ $re ]] && : || { printf "${RED} ERROR get-s3-version: no match${CLEAR}"; exit 1; }
  ver=${BASH_REMATCH[1]}
  echo "${ver}"
#+end_src

** Compare Replace

#+begin_comment
The following source code tangles all files during an export operation.  This
is to make sure the ~cmprpl~ source code exists in the ~tools/~ directory
before running the Makefile target =html=, as this directory is deleted upon a
~make clean-dist~.  It also makes sure there is a Makefile on an initial
export, although the Makefile is never thereafter deleted.  The following code
is not exported.
#+end_comment

#+name:tangle-org-file
#+header: :exports results :eval yes :results silent
#+begin_src emacs-lisp
(org-babel-tangle-file (buffer-file-name))
#+end_src

The ~cmprpl~ source code attempts to resolve the issue of identical exported
code having different time stamps, thus defeating the benefit provided by the
~aws2 s3 sync~ command uploading only changed files.

This program makes sure that a generated HTML directory exists: $NEWDIR.  If it
doesn’t, then it is in an improper state and the program stops with an error
message.

The program then checks if an old directory exists, $OLDDIR.  If one doesn’t,
then one is created by copying the current new directory.  This provides a
baseline for comparisons going forward.

The program then loops through all of the files in the new directory and copies
any that do not exist in the old directory.  Now both directories should be in
sync.

It is important to retain the $OLDDIR for as long as possible to reap the most
benefits from the AWS S3 ~sync~ command.

#+caption:Compare Replace program
#+name:cmprpl
#+header: :mkdirp t
#+header: :shebang "#!/usr/bin/env bash"
#+begin_src sh :tangle tools/cmprpl
  [[ $# -eq 2 ]] || { echo "ERROR: Incorrect command line arguments"; exit 1; }
  NEWDIR=$1
  OLDDIR=$2

  [[ -d $NEWDIR ]] || { echo "ERROR: $NEWDIR does not exist"; exit 1; }
  [[ -d $OLDDIR ]] || { echo "CREATING: $OLDDIR does not exist"; cp -a $NEWDIR $OLDDIR; exit 0; }

  for oldfile in $OLDDIR/*
  do
      newfile=$NEWDIR/$(basename $oldfile)
      if [[ -e $newfile ]]
      then
	      if cmp -s $newfile $oldfile
	      then
	          printf "${GREEN}copying OLD to NEW${CLEAR}: "
	          cp -vp $oldfile $newfile
	      else
	          printf "${MAGENTA}copying NEW to OLD${CLEAR}: "
	          cp -vp $newfile $oldfile
	      fi
      else
	      printf "${RED}removing OLD:${CLEAR} "
	      rm -v $oldfile
      fi
  done

  for newfile in $NEWDIR/*
  do
      oldfile=$OLDDIR/$(basename $newfile)
      [[ -e $oldfile ]] || { printf "${BLUE}copying NEW to OLD${CLEAR}: "
			     cp -vp $newfile $oldfile; }
  done
#+end_src


* List of Programs
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Listing

* List of Examples
:PROPERTIES:
:appendix: t
:END:
#+texinfo:@listoffloats Example

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright \copy 2020 by {{{author}}}

* Concept Index
:PROPERTIES:
:unnumbered: t
:index:    cp
:END:

* Program Index
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Function Index
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Variable Index
:PROPERTIES:
:index:    vr
:unnumbered: t
:END:


* Footnotes


* Export Configurations                                            :noexport:
#+texinfo_filename:clojure.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+texinfo_dir_category:Programming Languages
#+texinfo_dir_title:Clojure
#+texinfo_dir_desc:All about the elegant language of Clojure
#+texinfo_printed_title:All About Clojure


* Local Variables                                                  :noexport:
# Local Variables:
# fill-column: 79
# indent-tabs-mode: t
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (electric-quote-local-mode t)
# End:
